<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prot√≥tipo 3D - RPG G√≥tico Hi-Tech</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Courier New', Courier, monospace; 
        }
        canvas { 
            display: block; 
        }
        #info-panel { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            padding: 15px; 
            background-color: rgba(0, 0, 0, 0.7); 
            color: #00ffcc; 
            border: 2px solid #00ffcc; 
            border-radius: 8px; 
            font-size: 14px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
        }
        #info-panel h3 {
            margin: 0 0 10px 0;
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }
        #info-panel p {
            margin: 5px 0;
        }
        
        /* === ESTILOS DO EDITOR === */
        .tool-btn, .brush-btn {
            padding: 8px 12px;
            background: #2a2a3a;
            color: #00ffcc;
            border: 1px solid #00ffcc;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .tool-btn:hover, .brush-btn:hover {
            background: #00ffcc;
            color: #000;
        }
        
        .tool-btn.active, .brush-btn.active {
            background: #00ffcc;
            color: #000;
        }
        
        .asset-item {
            padding: 8px;
            margin: 5px 0;
            background: #1a1a2a;
            border: 1px solid #333;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .asset-item:hover {
            background: #2a2a3a;
            border-color: #00ffcc;
        }
        
        .property-group {
            margin: 10px 0;
        }
        
        .property-group label {
            display: block;
            margin-bottom: 5px;
            color: #00ffcc;
        }
        
        .property-group input {
            width: 100%;
            padding: 5px;
            background: #1a1a2a;
            color: #00ffcc;
            border: 1px solid #333;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="info-panel" style="display: none;">
        <h3>üåô RPG G√≥tico Hi-Tech - Prot√≥tipo</h3>
        <p><strong>Movimento:</strong> W, A, S, D</p>
        <p><strong>Corrida:</strong> SHIFT + WASD</p>
        <p><strong>Voo:</strong> F (ativar/desativar)</p>
        <p><strong>Voo:</strong> Espa√ßo (subir) / C (descer)</p>
        <p><strong>Pulo:</strong> Espa√ßo (no ch√£o)</p>
        <p><strong>Ataque:</strong> E (anima√ß√£o FBX)</p>
        <p><strong>C√¢mera:</strong> Bot√£o direito + Arrastar</p>
        <p><strong>Vis√£o:</strong> V (1¬™/3¬™ pessoa)</p>
        <p><strong>Texturas:</strong> CyberSample 4K + VoxelCity</p>
        <p><strong>Elementos:</strong> Pr√©dios, Estradas, Props Urbanos</p>
        <p><strong>Atmosfera:</strong> Tecno-Medieval + Retr√¥-Futurista</p>
        <div id="status-indicators">
            <p id="flying-status" style="color: #ff6b6b; display: none;">‚úàÔ∏è MODO VOO ATIVO</p>
            <p id="running-status" style="color: #00ffcc; display: none;">üèÉ CORRENDO</p>
        </div>
    </div>

    <!-- Bot√£o de Toggle do Editor (sempre vis√≠vel) -->
    <button id="toggle-editor" style="position: absolute; bottom: 20px; left: 20px; padding: 10px; background: #00ffcc; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; z-index: 1000;">
        üîß EDITOR
    </button>

    <!-- === INTERFACE DO EDITOR DE MAPAS === -->
    <div id="editor-ui" style="display: none;">

        <!-- Barra de Ferramentas Superior -->
        <div id="toolbar" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.8); padding: 10px; border-radius: 5px; display: flex; gap: 10px;">
            <button id="tool-translate" class="tool-btn active" data-tool="translate">‚ÜîÔ∏è Mover</button>
            <button id="tool-rotate" class="tool-btn" data-tool="rotate">üîÑ Rotacionar</button>
            <button id="tool-scale" class="tool-btn" data-tool="scale">üìè Escalar</button>
            <button id="tool-paint" class="tool-btn" data-tool="paint">üé® Pintar</button>
        </div>

        <!-- Painel Esquerdo - Biblioteca de Assets -->
        <div id="asset-library" style="position: absolute; top: 60px; left: 10px; width: 250px; height: 400px; background: rgba(0, 0, 0, 0.8); color: #00ffcc; padding: 15px; border-radius: 5px; overflow-y: auto;">
            <h3 style="margin-top: 0; color: #00ffcc;">üì¶ Biblioteca de Assets</h3>
            <div id="asset-list">
                <p style="color: #666;">Carregando assets...</p>
            </div>
        </div>

        <!-- Painel Direito - Inspetor de Propriedades -->
        <div id="inspector" style="position: absolute; top: 60px; right: 10px; width: 250px; height: 400px; background: rgba(0, 0, 0, 0.8); color: #00ffcc; padding: 15px; border-radius: 5px;">
            <h3 style="margin-top: 0; color: #00ffcc;">‚öôÔ∏è Propriedades</h3>
            <div id="object-properties">
                <p style="color: #666;">Nenhum objeto selecionado</p>
            </div>
        </div>

        <!-- Painel de Pinc√©is de Terreno -->
        <div id="terrain-brushes" style="position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.8); padding: 10px; border-radius: 5px; display: none;">
            <h4 style="margin-top: 0; color: #00ffcc;">üé® Pinc√©is de Terreno</h4>
            <div style="display: flex; gap: 10px;">
                <button class="brush-btn active" data-brush="grass">üå± Grama</button>
                <button class="brush-btn" data-brush="dirt">üü´ Terra</button>
                <button class="brush-btn" data-brush="stone">ü™® Pedra</button>
                <button class="brush-btn" data-brush="metal">‚öôÔ∏è Metal</button>
            </div>
        </div>
    </div>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    { 
        "imports": { 
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        } 
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // Inicializa√ß√£o da cena
        const scene = new THREE.Scene();
        
        // === SISTEMA DE EDITOR DE MAPAS ===
        let isEditMode = false;
        let selectedObject = null;
        let transformControls = null;
        let gridHelper = null;
        let assetLibrary = {};
        let placedObjects = [];
        let currentTool = 'translate';
        let currentBrush = 'grass';
        let isPlacingAsset = false;
        let assetToPlace = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // Inicializar texture loader
        const textureLoader = new THREE.TextureLoader();
        
        // Configura√ß√£o da n√©voa para atmosfera sombria
        scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
        
        // Configura√ß√£o da c√¢mera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        
        // Configura√ß√£o do renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x87CEEB);
        document.body.appendChild(renderer.domElement);

        // Ilumina√ß√£o ambiente mais natural
        const ambientLight = new THREE.AmbientLight(0x606060, 1.5);
        scene.add(ambientLight);

        // Luz solar direcional
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
        directionalLight.position.set(50, 50, 25);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -25;
        directionalLight.shadow.camera.right = 25;
        directionalLight.shadow.camera.top = 25;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);
        
        // Ilumina√ß√£o adicional para melhorar as cores
        // const pointLight1 = new THREE.PointLight(0x00ffcc, 0.5, 30); ... (removido)
        // const pointLight2 = new THREE.PointLight(0xff6b6b, 0.3, 20); ... (removido)
        // etc...

        // Ch√£o do cen√°rio com textura de grama/terra
        const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
        
        // Gerar texturas 3D para o ch√£o
        const groundTextures = generate3DTextures(512, 'grass_terrain');
        
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            map: groundTextures.albedo,
            normalMap: groundTextures.normal,
            roughnessMap: groundTextures.roughness,
            metalnessMap: groundTextures.metalness,
            displacementMap: groundTextures.height,
            displacementScale: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.name = 'ground'; // Nome para o sistema de pintura
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Carregar texturas de pr√©dios cyberpunk
        const cyberTextures = {};
        
        // Fun√ß√£o para carregar texturas com fallback
        function loadCyberTexture(path, name) {
            const texture = textureLoader.load(
                path,
                () => console.log(`Textura carregada: ${name}`),
                undefined,
                (error) => {
                    console.warn(`Erro ao carregar ${name}:`, error);
                    // Usar textura procedural como fallback
                    return createProceduralTexture(256, 'building');
                }
            );
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        // Carregar texturas de pr√©dios (caminhos corrigidos)
        cyberTextures.buildings1 = loadCyberTexture('CyberSample/FreeSample/Textures/T_Buildings_001Diffuse-4K.png', 'Buildings 1');
        cyberTextures.buildings2 = loadCyberTexture('CyberSample/FreeSample/Textures/T_Buildings_002Diffuse-4K.png', 'Buildings 2');
        cyberTextures.buildingsEmissive1 = loadCyberTexture('CyberSample/FreeSample/Textures/BAKE_Buildings_001Emissive-4K.png', 'Buildings Emissive 1');
        cyberTextures.buildingsEmissive2 = loadCyberTexture('CyberSample/FreeSample/Textures/BAKE_Buildings_002Emissive-4K.png', 'Buildings Emissive 2');
        cyberTextures.roads = loadCyberTexture('CyberSample/FreeSample/Textures/T_RoadsDiffuse-4K.png', 'Roads');
        cyberTextures.roadsEmissive = loadCyberTexture('CyberSample/FreeSample/Textures/BAKE_RoadsEmissive-4K.png', 'Roads Emissive');
        cyberTextures.props = loadCyberTexture('CyberSample/FreeSample/Textures/T_PropsDiffuse-4K.png', 'Props');
        cyberTextures.propsEmissive = loadCyberTexture('CyberSample/FreeSample/Textures/BAKE_PropsEmissive-4K.png', 'Props Emissive');
        
        // Carregar texturas VoxelCity
        cyberTextures.voxelBuildings1 = loadCyberTexture('CyberSample/FreeSample/Textures/VoxelCity_CompositeBuildings_Optimized-0_diffuse.png', 'Voxel Buildings 1');
        cyberTextures.voxelBuildings2 = loadCyberTexture('CyberSample/FreeSample/Textures/VoxelCity_CompositeBuildings_Optimized-2_diffuse.png', 'Voxel Buildings 2');
        cyberTextures.voxelBuildings3 = loadCyberTexture('CyberSample/FreeSample/Textures/VoxelCity_CompositeBuildings_Optimized-4_diffuse.png', 'Voxel Buildings 3');
        cyberTextures.voxelColor = loadCyberTexture('CyberSample/FreeSample/Textures/VoxelCity_CompositeBuildings_Optimized-4_Color.png', 'Voxel Color');
        
        // Fun√ß√£o para criar textura procedural como fallback
        function createProceduralTexture(size, type) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Base escura
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(0, 0, size, size);
            
            // Adicionar padr√µes baseados no tipo
            if (type === 'building') {
                // Padr√£o de janelas
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const w = Math.random() * 20 + 10;
                    const h = Math.random() * 30 + 15;
                    
                    ctx.fillStyle = Math.random() > 0.5 ? '#00ffcc' : '#ff6b6b';
                    ctx.fillRect(x, y, w, h);
                }
                
                // Linhas estruturais
                ctx.strokeStyle = '#333343';
                ctx.lineWidth = 2;
                for (let i = 0; i < 20; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * size / 20);
                    ctx.lineTo(size, i * size / 20);
                    ctx.stroke();
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Vers√£o base do construtor de pr√©dios
        function createGothicTechBuilding(options) {
            const building = new THREE.Group();
            building.userData.isProceduralBuilding = true;
            building.position.set(options.x, options.y, options.z);
            building.rotation.y = (Math.random() - 0.5) * 0.2; // Adiciona leve rota√ß√£o
            
            const width = 5 + Math.random() * 3;
            const depth = 5 + Math.random() * 3;
            const height = 9 + Math.random() * 8;

            // --- Materiais ---
            const plasterTextures = generate3DTextures(256, 'plaster_wall');
            const plasterMaterial = new THREE.MeshStandardMaterial({ map: plasterTextures.albedo, normalMap: plasterTextures.normal, roughnessMap: plasterTextures.roughness });
            const woodTextures = generate3DTextures(256, 'wood_planks');
            const woodMaterial = new THREE.MeshStandardMaterial({ map: woodTextures.albedo, normalMap: woodTextures.normal, roughnessMap: woodTextures.roughness });

            // --- Montagem Modular ---
            // 1. Corpo principal (parede de gesso)
            const mainWall = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), plasterMaterial);
            mainWall.position.y = height / 2;
            mainWall.castShadow = true;
            mainWall.receiveShadow = true;
            building.add(mainWall);

            // 2. Estrutura de vigas de madeira (detalhe 3D)
            const beamSize = 0.2;
            // Vigas Verticais
            const vBeamGeo = new THREE.BoxGeometry(beamSize, height + beamSize, beamSize);
            for (let i = 0; i < 4; i++) {
                const beam = new THREE.Mesh(vBeamGeo, woodMaterial);
                const x = (i < 2 ? -1 : 1) * width / 2;
                const z = (i % 2 === 0 ? -1 : 1) * depth / 2;
                beam.position.set(x, height / 2, z);
                beam.castShadow = true;
                building.add(beam);
            }
            // Vigas Horizontais (Topo e Base)
            const hBeamGeoX = new THREE.BoxGeometry(width + beamSize, beamSize, beamSize);
            const hBeamGeoZ = new THREE.BoxGeometry(beamSize, beamSize, depth + beamSize);
            for (let y of [0, height]) {
                 for (let i = 0; i < 2; i++) {
                    const beamX = new THREE.Mesh(hBeamGeoX, woodMaterial);
                    beamX.position.set(0, y, (i === 0 ? -1 : 1) * depth / 2);
                    building.add(beamX);
                    const beamZ = new THREE.Mesh(hBeamGeoZ, woodMaterial);
                    beamZ.position.set((i === 0 ? -1 : 1) * width / 2, y, 0);
                    building.add(beamZ);
                }
            }

            // 3. Telhado √çngreme
            const roofHeight = height * (0.4 + Math.random() * 0.2);
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(Math.max(width, depth) * 0.8, roofHeight, 4, 1), 
                woodMaterial
            );
            roof.position.y = height + (roofHeight / 2) - beamSize;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            building.add(roof);


            scene.add(building);
            return building;
        }
        
        // Fun√ß√£o para criar pr√©dio residencial
        function createResidentialBuilding(x, z, width, height, depth) {
            const buildingGroup = new THREE.Group();
            
            // Material residencial com textura mais suave
            const residentialMaterial = new THREE.MeshStandardMaterial({
                map: cyberTextures.buildings1,
                emissiveMap: cyberTextures.buildingsEmissive1,
                emissive: new THREE.Color().setHSL(0.1, 0.2, 0.05),
                roughness: 0.6,
                metalness: 0.2
            });
            
            if (cyberTextures.buildings1) {
                cyberTextures.buildings1.repeat.set(width / 6, height / 12);
            }
            
            // Corpo principal
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth), 
                residentialMaterial
            );
            mainBuilding.position.y = height / 2;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            buildingGroup.add(mainBuilding);
            
            // Janelas residenciais
            const windowCount = Math.floor(height / 4);
            for (let i = 0; i < windowCount; i++) {
                const windowY = (i + 1) * (height / (windowCount + 1));
                
                // Janelas com luzes quentes
                const window = new THREE.Mesh(
                    new THREE.PlaneGeometry(width * 0.3, height * 0.15),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffaa44,
                        emissive: 0x442200,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                window.position.set(width/2 + 0.01, windowY, 0);
                buildingGroup.add(window);
            }
            
            buildingGroup.position.set(x, 0, z);
            return buildingGroup;
        }
        
        // Fun√ß√£o para criar pr√©dio comercial
        function createCommercialBuilding(x, z, width, height, depth) {
            const buildingGroup = new THREE.Group();
            
            // Material comercial com textura mais met√°lica
            const commercialMaterial = new THREE.MeshStandardMaterial({
                map: cyberTextures.buildings2,
                emissiveMap: cyberTextures.buildingsEmissive2,
                emissive: new THREE.Color().setHSL(0.6, 0.4, 0.1),
                roughness: 0.2,
                metalness: 0.8
            });
            
            if (cyberTextures.buildings2) {
                cyberTextures.buildings2.repeat.set(width / 4, height / 8);
            }
            
            // Corpo principal
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth), 
                commercialMaterial
            );
            mainBuilding.position.y = height / 2;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            buildingGroup.add(mainBuilding);
            
            // An√∫ncios neon
            const adCount = Math.floor(height / 6);
            for (let i = 0; i < adCount; i++) {
                const adY = (i + 1) * (height / (adCount + 1));
                
                const ad = new THREE.Mesh(
                    new THREE.PlaneGeometry(width * 0.8, height * 0.2),
                    new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6),
                        emissive: new THREE.Color().setHSL(Math.random(), 0.8, 0.3),
                        transparent: true,
                        opacity: 0.8
                    })
                );
                ad.position.set(0, adY, depth/2 + 0.01);
                buildingGroup.add(ad);
            }
            
            buildingGroup.position.set(x, 0, z);
            return buildingGroup;
        }
        
        // Criar pr√©dios variados
        for (let i = 0; i < 20; i++) {
            const height = Math.random() * 25 + 8;
            const width = Math.random() * 8 + 4;
            const depth = Math.random() * 8 + 4;
            
            const building = createGothicTechBuilding(
                (Math.random() - 0.5) * 150, 
                (Math.random() - 0.5) * 150,
                width, height, depth
            );
            
            scene.add(building);
        }
        
        // Criar pr√©dios residenciais
        for (let i = 0; i < 15; i++) {
            const height = Math.random() * 15 + 5;
            const width = Math.random() * 6 + 3;
            const depth = Math.random() * 6 + 3;
            
            const building = createResidentialBuilding(
                (Math.random() - 0.5) * 150, 
                (Math.random() - 0.5) * 150,
                width, height, depth
            );
            
            scene.add(building);
        }
        
        // Criar pr√©dios comerciais
        for (let i = 0; i < 10; i++) {
            const height = Math.random() * 30 + 10;
            const width = Math.random() * 12 + 6;
            const depth = Math.random() * 12 + 6;
            
            const building = createCommercialBuilding(
                (Math.random() - 0.5) * 150, 
                (Math.random() - 0.5) * 150,
                width, height, depth
            );
            
            scene.add(building);
        }
        
        // Adicionar estruturas especiais
        // Catedral central
        const cathedral = createGothicTechBuilding(0, 0, 15, 35, 20);
        scene.add(cathedral);
        
        // Torres de energia
        for (let i = 0; i < 5; i++) {
            const energyTower = new THREE.Group();
            
            const towerHeight = 40 + Math.random() * 20;
            const tower = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 3, towerHeight, 12),
                new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a3a,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: 0x001122
                })
            );
            tower.position.y = towerHeight / 2;
            tower.castShadow = true;
            energyTower.add(tower);
            
            // An√©is de energia
            for (let j = 0; j < 3; j++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(4 + j * 2, 0.2, 8, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ffcc,
                        emissive: 0x004433,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                ring.position.y = towerHeight * 0.3 + j * towerHeight * 0.2;
                energyTower.add(ring);
            }
            
            energyTower.position.set(
                (Math.random() - 0.5) * 200, 
                0, 
                (Math.random() - 0.5) * 200
            );
            scene.add(energyTower);
        }
        
        // Sistema de estradas cyberpunk
        function createCyberRoad(x, z, width, length, rotation = 0) {
            const roadGeometry = new THREE.PlaneGeometry(width, length, 10, 10);
            const roadMaterial = new THREE.MeshStandardMaterial({
                map: cyberTextures.roads,
                emissiveMap: cyberTextures.roadsEmissive,
                color: 0x2a2a2a,
                roughness: 0.8,
                metalness: 0.1,
                emissive: 0x001122
            });
            
            if (cyberTextures.roads) {
                cyberTextures.roads.repeat.set(width / 4, length / 4);
            }
            if (cyberTextures.roadsEmissive) {
                cyberTextures.roadsEmissive.repeat.set(width / 4, length / 4);
            }
            
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.set(x, 0.02, z);
            road.rotation.y = rotation;
            road.receiveShadow = true;
            scene.add(road);
            
            // Adicionar linhas de neon na estrada (melhoradas)
            const lineGeometry = new THREE.PlaneGeometry(width * 0.8, 0.5);
            const lineMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffcc,
                emissive: 0x004433,
                transparent: true,
                opacity: 0.8
            });
            
            for (let i = 0; i < 3; i++) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2;
                line.position.set(x, 0.03, z + (i - 1) * length / 3);
                line.rotation.y = rotation;
                scene.add(line);
            }
            
            // Adicionar postes de luz nas laterais da estrada
            for (let i = 0; i < Math.floor(length / 20); i++) {
                const poste = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 6, 8),
                    new THREE.MeshStandardMaterial({
                        map: cyberTextures.props,
                        color: 0x333333,
                        metalness: 0.8,
                        roughness: 0.2
                    })
                );
                poste.position.set(x + width/2 + 1, 3, z + (i - Math.floor(length / 40)) * 20);
                poste.rotation.y = rotation;
                scene.add(poste);
                
                // Luz do poste
                const posteLight = new THREE.PointLight(0x00ffcc, 0.6, 15);
                posteLight.position.set(x + width/2 + 1, 6, z + (i - Math.floor(length / 40)) * 20);
                scene.add(posteLight);
            }
        }
        
        // Criar rede de estradas
        createCyberRoad(0, 0, 200, 8, 0); // Estrada principal horizontal
        createCyberRoad(0, 0, 8, 200, Math.PI / 2); // Estrada principal vertical
        createCyberRoad(-50, 0, 100, 6, 0); // Estrada secund√°ria
        createCyberRoad(0, -50, 6, 100, Math.PI / 2); // Estrada secund√°ria
        createCyberRoad(50, 0, 100, 6, 0); // Estrada secund√°ria
        createCyberRoad(0, 50, 6, 100, Math.PI / 2); // Estrada secund√°ria
        
        // Fun√ß√£o para criar pr√©dio VoxelCity (estilo retr√¥-futurista)
        function createVoxelBuilding(x, z, width, height, depth) {
            const buildingGroup = new THREE.Group();
            
            // Escolher textura voxel aleat√≥ria
            const voxelTextures = [cyberTextures.voxelBuildings1, cyberTextures.voxelBuildings2, cyberTextures.voxelBuildings3];
            const voxelTexture = voxelTextures[Math.floor(Math.random() * voxelTextures.length)];
            
            // Material voxel com textura especial
            const voxelMaterial = new THREE.MeshStandardMaterial({
                map: voxelTexture,
                color: new THREE.Color().setHSL(Math.random(), 0.3, 0.5),
                roughness: 0.8,
                metalness: 0.1,
                emissive: new THREE.Color().setHSL(Math.random(), 0.5, 0.1)
            });
            
            if (voxelTexture) {
                voxelTexture.repeat.set(width / 8, height / 16);
            }
            
            // Corpo principal em estilo voxel (mais blocado)
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth), 
                voxelMaterial
            );
            mainBuilding.position.y = height / 2;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            buildingGroup.add(mainBuilding);
            
            // Adicionar blocos menores para efeito voxel
            for (let i = 0; i < 5; i++) {
                const blockSize = Math.random() * 2 + 1;
                const block = new THREE.Mesh(
                    new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                    voxelMaterial
                );
                block.position.set(
                    (Math.random() - 0.5) * width,
                    height + blockSize / 2,
                    (Math.random() - 0.5) * depth
                );
                buildingGroup.add(block);
            }
            
            // Luzes neon caracter√≠sticas do estilo voxel
            const neonLight = new THREE.PointLight(
                new THREE.Color().setHSL(Math.random(), 0.8, 0.6), 
                0.5, 
                15
            );
            neonLight.position.set(0, height * 0.8, 0);
            buildingGroup.add(neonLight);
            
            buildingGroup.position.set(x, 0, z);
            return buildingGroup;
        }
        
        // Fun√ß√£o para criar props urbanos
        function createUrbanProps(x, z, count = 5) {
            const propsGroup = new THREE.Group();
            
            for (let i = 0; i < count; i++) {
                const propType = Math.floor(Math.random() * 4);
                let prop;
                
                switch(propType) {
                    case 0: // Poste de luz
                        prop = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.2, 0.2, 8, 8),
                            new THREE.MeshStandardMaterial({
                                map: cyberTextures.props,
                                color: 0x333333,
                                metalness: 0.8,
                                roughness: 0.2
                            })
                        );
                        prop.position.y = 4;
                        
                        // Luz no topo
                        const light = new THREE.PointLight(0x00ffcc, 0.8, 20);
                        light.position.set(0, 8, 0);
                        prop.add(light);
                        break;
                        
                    case 1: // Lixeira
                        prop = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.8, 0.8, 1.5, 8),
                            new THREE.MeshStandardMaterial({
                                map: cyberTextures.props,
                                color: 0x444444,
                                metalness: 0.6,
                                roughness: 0.4
                            })
                        );
                        prop.position.y = 0.75;
                        break;
                        
                    case 2: // Placa de sinaliza√ß√£o
                        prop = new THREE.Mesh(
                            new THREE.PlaneGeometry(2, 1),
                            new THREE.MeshStandardMaterial({
                                map: cyberTextures.props,
                                color: 0x00ffcc,
                                emissive: 0x004433,
                                transparent: true,
                                opacity: 0.9
                            })
                        );
                        prop.position.y = 3;
                        prop.rotation.y = Math.random() * Math.PI * 2;
                        break;
                        
                    case 3: // Caixa de utilidades
                        prop = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            new THREE.MeshStandardMaterial({
                                map: cyberTextures.props,
                                color: 0x666666,
                                metalness: 0.7,
                                roughness: 0.3
                            })
                        );
                        prop.position.y = 0.5;
                        break;
                }
                
                if (prop) {
                    prop.position.x += (Math.random() - 0.5) * 10;
                    prop.position.z += (Math.random() - 0.5) * 10;
                    propsGroup.add(prop);
                }
            }
            
            propsGroup.position.set(x, 0, z);
            return propsGroup;
        }
        
        // Criar √°rea VoxelCity (bairro retr√¥-futurista)
        for (let i = 0; i < 8; i++) {
            const height = Math.random() * 20 + 10;
            const width = Math.random() * 6 + 4;
            const depth = Math.random() * 6 + 4;
            
            const voxelBuilding = createVoxelBuilding(
                (Math.random() - 0.5) * 100 + 80, // √Årea espec√≠fica
                (Math.random() - 0.5) * 100 + 80,
                width, height, depth
            );
            
            scene.add(voxelBuilding);
        }
        
        // Criar props urbanos espalhados pela cidade
        for (let i = 0; i < 20; i++) {
            const props = createUrbanProps(
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200,
                Math.floor(Math.random() * 3) + 2
            );
            scene.add(props);
        }

        // === SISTEMA DE GERA√á√ÉO DE TEXTURAS 3D AVAN√áADO ===
        
        // Fun√ß√£o principal para gerar um conjunto completo de texturas PBR
        function generate3DTextures(size, type) {
            const textures = {};
            const heightCanvas = generateHeightMap(size, type); // Gerar altura primeiro, pois outros mapas podem depender dela
            textures.height = new THREE.CanvasTexture(heightCanvas);
            textures.albedo = new THREE.CanvasTexture(generateAlbedoMap(size, type, heightCanvas));
            textures.normal = new THREE.CanvasTexture(generateNormalMap(size, type, heightCanvas));
            textures.roughness = new THREE.CanvasTexture(generateRoughnessMap(size, type, heightCanvas));
            textures.metalness = new THREE.CanvasTexture(generateMetalnessMap(size, type)); // Metalness geralmente n√£o depende da altura
            
            // Configurar wrapping para todas as texturas
            for (const key in textures) {
                textures[key].wrapS = THREE.RepeatWrapping;
                textures[key].wrapT = THREE.RepeatWrapping;
            }
            return textures;
        }

        // Gera o mapa de cores (Albedo)
        function generateAlbedoMap(size, type, heightCanvas) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const heightCtx = heightCanvas.getContext('2d', { willReadFrequently: true });
            const heightData = heightCtx.getImageData(0, 0, size, size).data;

            let baseColor, patternColor, detailColor;
            switch(type) {
                case 'cobblestone': baseColor = '#5a5a5a'; patternColor = '#6a6a6a'; detailColor = '#404040'; break;
                case 'wood_planks': baseColor = '#8B4513'; patternColor = '#A0522D'; detailColor = '#5C3317'; break;
                case 'plaster_wall': baseColor = '#F5F5DC'; patternColor = '#E0E0C8'; detailColor = '#C8C8B4'; break;
                case 'grass_terrain': baseColor = '#2a3a2a'; patternColor = '#3a4a3a'; detailColor = '#1a2a1a'; break;
                default: baseColor = '#808080'; patternColor = '#909090'; detailColor = '#707070';
            }
            
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, size, size);

            // Adiciona varia√ß√£o de cor com base na altura
            for (let i = 0; i < heightData.length; i += 4) {
                const height = heightData[i] / 255; // Normaliza a altura (0-1)
                const variation = (height - 0.5) * 0.2; // -0.1 a 0.1
                const color = new THREE.Color(baseColor).offsetHSL(0, 0, variation);
                
                const x = (i / 4) % size;
                const y = Math.floor((i / 4) / size);
                
                ctx.fillStyle = `#${color.getHexString()}`;
                ctx.fillRect(x, y, 1, 1);
            }

            // Desenha padr√µes espec√≠ficos sobre a base variada
            if (type === 'cobblestone') generateCobblestonePattern(ctx, size, patternColor, detailColor);
            if (type === 'wood_planks') generateWoodPlankPattern(ctx, size, patternColor, detailColor);
            
            return canvas;
        }

        // Gera o Normal Map para simular relevo
        function generateNormalMap(size, type, heightCanvas) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const heightCtx = heightCanvas.getContext('2d', { willReadFrequently: true });
            const heightData = heightCtx.getImageData(0, 0, size, size).data;
            const normalData = ctx.createImageData(size, size);
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    // Pega a altura dos pixels vizinhos para calcular a inclina√ß√£o
                    const hL = getHeight(x - 1, y, size, heightData) / 255.0; // Left
                    const hR = getHeight(x + 1, y, size, heightData) / 255.0; // Right
                    const hD = getHeight(x, y - 1, size, heightData) / 255.0; // Down
                    const hU = getHeight(x, y + 1, size, heightData) / 255.0; // Up

                    const n = new THREE.Vector3(hL - hR, hD - hU, 2.0).normalize();
                    
                    const index = (y * size + x) * 4;
                    normalData.data[index + 0] = (n.x * 0.5 + 0.5) * 255; // R
                    normalData.data[index + 1] = (n.y * 0.5 + 0.5) * 255; // G
                    normalData.data[index + 2] = (n.z * 0.5 + 0.5) * 255; // B
                    normalData.data[index + 3] = 255; // Alpha
                }
            }
            ctx.putImageData(normalData, 0, 0);
            return canvas;
        }
        
        function getHeight(x, y, size, data) {
            x = Math.max(0, Math.min(size - 1, x));
            y = Math.max(0, Math.min(size - 1, y));
            return data[(y * size + x) * 4];
        }
        
        // Gera o Height Map (escala de cinza para deslocamento)
        function generateHeightMap(size, type) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.fillStyle = '#808080'; // Base cinza
            ctx.fillRect(0, 0, size, size);

            if (type === 'cobblestone') generateCobblestoneHeight(ctx, size);
            if (type === 'wood_planks') generateWoodPlankHeight(ctx, size);
            if (type === 'grass_terrain') generateGrassHeight(ctx, size);

            return canvas;
        }
        
        // Gera o Roughness Map
        function generateRoughnessMap(size, type, heightCanvas) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const heightCtx = heightCanvas.getContext('2d', { willReadFrequently: true });
            const heightData = heightCtx.getImageData(0, 0, size, size).data;

            let baseRoughness, variation;
            switch(type) {
                case 'cobblestone': baseRoughness = 0.8; variation = 0.1; break;
                case 'wood_planks': baseRoughness = 0.7; variation = 0.2; break;
                case 'plaster_wall': baseRoughness = 0.9; variation = 0.05; break;
                case 'grass_terrain': baseRoughness = 0.85; variation = 0.1; break;
                default: baseRoughness = 0.5; variation = 0.1;
            }
            
            // Varia a rugosidade com base na altura (√°reas mais baixas s√£o mais √°speras/molhadas)
            for (let i = 0; i < heightData.length; i += 4) {
                const height = heightData[i] / 255;
                const rough = baseRoughness + (height - 0.5) * variation;
                const gray = Math.floor(Math.max(0, Math.min(1, rough)) * 255);
                const x = (i / 4) % size;
                const y = Math.floor((i / 4) / size);
                ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                ctx.fillRect(x, y, 1, 1);
            }
            return canvas;
        }

        // Gera o Metalness Map
        function generateMetalnessMap(size, type) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const metalness = (type === 'metal_floor' || type === 'metal_details') ? 0.9 : 0.05;
            const gray = Math.floor(metalness * 255);
            ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
            ctx.fillRect(0, 0, size, size);
            return canvas;
        }
        
        // --- Fun√ß√µes de Padr√£o ---

        function generateCobblestonePattern(ctx, size, patternColor, detailColor) {
            const stoneSize = size / 8;
            for (let y = 0; y < size; y += stoneSize) {
                for (let x = 0; x < size; x += stoneSize) {
                    ctx.fillStyle = Math.random() > 0.5 ? patternColor : detailColor;
                    const offsetX = (Math.random() - 0.5) * stoneSize * 0.2;
                    const offsetY = (Math.random() - 0.5) * stoneSize * 0.2;
                    ctx.beginPath();
                    ctx.arc(x + stoneSize / 2 + offsetX, y + stoneSize / 2 + offsetY, stoneSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function generateWoodPlankPattern(ctx, size, patternColor, detailColor) {
            const plankWidth = size / 6;
            for (let x = 0; x < size; x += plankWidth) {
                ctx.fillStyle = patternColor;
                ctx.fillRect(x, 0, plankWidth, size);
                ctx.strokeStyle = detailColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(x, 0, plankWidth, size);
                // Wood grain
                for (let i = 0; i < 20; i++) {
                    ctx.beginPath();
                    ctx.moveTo(x + Math.random() * plankWidth, 0);
                    ctx.lineTo(x + Math.random() * plankWidth, size);
                    ctx.stroke();
                }
            }
        }
        
        function generateCobblestoneHeight(ctx, size) {
            const stoneSize = size / 8;
            for (let y = 0; y < size; y += stoneSize) {
                for (let x = 0; x < size; x += stoneSize) {
                    const height = Math.floor(Math.random() * 50 + 200); // Varia√ß√£o de altura para as pedras
                    ctx.fillStyle = `rgb(${height}, ${height}, ${height})`;
                    ctx.beginPath();
                    ctx.arc(x + stoneSize / 2, y + stoneSize / 2, stoneSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function generateWoodPlankHeight(ctx, size) {
            const plankWidth = size / 6;
            for (let x = 0; x < size; x += plankWidth) {
                const height = Math.floor(Math.random() * 20 + 220);
                ctx.fillStyle = `rgb(${height}, ${height}, ${height})`;
                ctx.fillRect(x, 0, plankWidth, size);
                // Gaps are lower
                ctx.fillStyle = 'rgb(50, 50, 50)';
                ctx.fillRect(x - 1, 0, 2, size);
            }
        }
        
        function generateGrassHeight(ctx, size) {
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = Math.random() * 40;
                const height = Math.floor(Math.random() * 100 + 128);
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgb(${height}, ${height}, ${height})`);
                gradient.addColorStop(1, 'rgb(128, 128, 128)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- CHAMADA PRINCIPAL PARA GERAR A CIDADE ---
        createGothicTechCity();

        let npcs = []; // Array mantido para evitar erros de refer√™ncia

        // === GERA√á√ÉO PROCEDURAL DO VILAREJO G√ìTICO HI-TECH ===

        function createGothicTechVillage() {
            // Esta fun√ß√£o ir√° orquestrar a cria√ß√£o do vilarejo.
            // O conte√∫do ser√° adicionado nos pr√≥ximos passos.
        }

        // --- CHAMADA PRINCIPAL ---
        createGothicTechVillage();

        // === SISTEMA DE GERA√á√ÉO DE TEXTURAS 3D AVAN√áADO ===
        
        // Fun√ß√£o principal para gerar um conjunto completo de texturas PBR
        function generate3DTextures(size, type) {
            const textures = {};
            const heightCanvas = generateHeightMap(size, type); // Gerar altura primeiro, pois outros mapas podem depender dela
            textures.height = new THREE.CanvasTexture(heightCanvas);
            textures.albedo = new THREE.CanvasTexture(generateAlbedoMap(size, type, heightCanvas));
            textures.normal = new THREE.CanvasTexture(generateNormalMap(size, type, heightCanvas));
            textures.roughness = new THREE.CanvasTexture(generateRoughnessMap(size, type, heightCanvas));
            textures.metalness = new THREE.CanvasTexture(generateMetalnessMap(size, type)); // Metalness geralmente n√£o depende da altura
            
            // Configurar wrapping para todas as texturas
            for (const key in textures) {
                textures[key].wrapS = THREE.RepeatWrapping;
                textures[key].wrapT = THREE.RepeatWrapping;
            }
            return textures;
        }

        // Gera o mapa de cores (Albedo)
        function generateAlbedoMap(size, type, heightCanvas) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const heightCtx = heightCanvas.getContext('2d', { willReadFrequently: true });
            const heightData = heightCtx.getImageData(0, 0, size, size).data;

            let baseColor, patternColor, detailColor;
            switch(type) {
                case 'cobblestone': baseColor = '#5a5a5a'; patternColor = '#6a6a6a'; detailColor = '#404040'; break;
                case 'wood_planks': baseColor = '#8B4513'; patternColor = '#A0522D'; detailColor = '#5C3317'; break;
                case 'plaster_wall': baseColor = '#F5F5DC'; patternColor = '#E0E0C8'; detailColor = '#C8C8B4'; break;
                case 'grass_terrain': baseColor = '#2a3a2a'; patternColor = '#3a4a3a'; detailColor = '#1a2a1a'; break;
                default: baseColor = '#808080'; patternColor = '#909090'; detailColor = '#707070';
            }
            
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, size, size);

            // Adiciona varia√ß√£o de cor com base na altura
            for (let i = 0; i < heightData.length; i += 4) {
                const height = heightData[i] / 255; // Normaliza a altura (0-1)
                const variation = (height - 0.5) * 0.2; // -0.1 a 0.1
                const color = new THREE.Color(baseColor).offsetHSL(0, 0, variation);
                
                const x = (i / 4) % size;
                const y = Math.floor((i / 4) / size);
                
                ctx.fillStyle = `#${color.getHexString()}`;
                ctx.fillRect(x, y, 1, 1);
            }

            // Desenha padr√µes espec√≠ficos sobre a base variada
            if (type === 'cobblestone') generateCobblestonePattern(ctx, size, patternColor, detailColor);
            if (type === 'wood_planks') generateWoodPlankPattern(ctx, size, patternColor, detailColor);
            
            return canvas;
        }

        // Gera o Normal Map para simular relevo
        function generateNormalMap(size, type, heightCanvas) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const heightCtx = heightCanvas.getContext('2d', { willReadFrequently: true });
            const heightData = heightCtx.getImageData(0, 0, size, size).data;
            const normalData = ctx.createImageData(size, size);
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    // Pega a altura dos pixels vizinhos para calcular a inclina√ß√£o
                    const hL = getHeight(x - 1, y, size, heightData) / 255.0; // Left
                    const hR = getHeight(x + 1, y, size, heightData) / 255.0; // Right
                    const hD = getHeight(x, y - 1, size, heightData) / 255.0; // Down
                    const hU = getHeight(x, y + 1, size, heightData) / 255.0; // Up

                    const n = new THREE.Vector3(hL - hR, hD - hU, 2.0).normalize();
                    
                    const index = (y * size + x) * 4;
                    normalData.data[index + 0] = (n.x * 0.5 + 0.5) * 255; // R
                    normalData.data[index + 1] = (n.y * 0.5 + 0.5) * 255; // G
                    normalData.data[index + 2] = (n.z * 0.5 + 0.5) * 255; // B
                    normalData.data[index + 3] = 255; // Alpha
                }
            }
            ctx.putImageData(normalData, 0, 0);
            return canvas;
        }
        
        function getHeight(x, y, size, data) {
            x = Math.max(0, Math.min(size - 1, x));
            y = Math.max(0, Math.min(size - 1, y));
            return data[(y * size + x) * 4];
        }
        
        // Gera o Height Map (escala de cinza para deslocamento)
        function generateHeightMap(size, type) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.fillStyle = '#808080'; // Base cinza
            ctx.fillRect(0, 0, size, size);

            if (type === 'cobblestone') generateCobblestoneHeight(ctx, size);
            if (type === 'wood_planks') generateWoodPlankHeight(ctx, size);
            if (type === 'grass_terrain') generateGrassHeight(ctx, size);

            return canvas;
        }
        
        // Gera o Roughness Map
        function generateRoughnessMap(size, type, heightCanvas) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const heightCtx = heightCanvas.getContext('2d', { willReadFrequently: true });
            const heightData = heightCtx.getImageData(0, 0, size, size).data;

            let baseRoughness, variation;
            switch(type) {
                case 'cobblestone': baseRoughness = 0.8; variation = 0.1; break;
                case 'wood_planks': baseRoughness = 0.7; variation = 0.2; break;
                case 'plaster_wall': baseRoughness = 0.9; variation = 0.05; break;
                case 'grass_terrain': baseRoughness = 0.85; variation = 0.1; break;
                default: baseRoughness = 0.5; variation = 0.1;
            }
            
            // Varia a rugosidade com base na altura (√°reas mais baixas s√£o mais √°speras/molhadas)
            for (let i = 0; i < heightData.length; i += 4) {
                const height = heightData[i] / 255;
                const rough = baseRoughness + (height - 0.5) * variation;
                const gray = Math.floor(Math.max(0, Math.min(1, rough)) * 255);
                const x = (i / 4) % size;
                const y = Math.floor((i / 4) / size);
                ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                ctx.fillRect(x, y, 1, 1);
            }
            return canvas;
        }

        // Gera o Metalness Map
        function generateMetalnessMap(size, type) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const metalness = (type === 'metal_floor' || type === 'metal_details') ? 0.9 : 0.05;
            const gray = Math.floor(metalness * 255);
            ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
            ctx.fillRect(0, 0, size, size);
            return canvas;
        }
        
        // --- Fun√ß√µes de Padr√£o ---

        function generateCobblestonePattern(ctx, size, patternColor, detailColor) {
            const stoneSize = size / 8;
            for (let y = 0; y < size; y += stoneSize) {
                for (let x = 0; x < size; x += stoneSize) {
                    ctx.fillStyle = Math.random() > 0.5 ? patternColor : detailColor;
                    const offsetX = (Math.random() - 0.5) * stoneSize * 0.2;
                    const offsetY = (Math.random() - 0.5) * stoneSize * 0.2;
                    ctx.beginPath();
                    ctx.arc(x + stoneSize / 2 + offsetX, y + stoneSize / 2 + offsetY, stoneSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function generateWoodPlankPattern(ctx, size, patternColor, detailColor) {
            const plankWidth = size / 6;
            for (let x = 0; x < size; x += plankWidth) {
                ctx.fillStyle = patternColor;
                ctx.fillRect(x, 0, plankWidth, size);
                ctx.strokeStyle = detailColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(x, 0, plankWidth, size);
                // Wood grain
                for (let i = 0; i < 20; i++) {
                    ctx.beginPath();
                    ctx.moveTo(x + Math.random() * plankWidth, 0);
                    ctx.lineTo(x + Math.random() * plankWidth, size);
                    ctx.stroke();
                }
            }
        }
        
        function generateCobblestoneHeight(ctx, size) {
            const stoneSize = size / 8;
            for (let y = 0; y < size; y += stoneSize) {
                for (let x = 0; x < size; x += stoneSize) {
                    const height = Math.floor(Math.random() * 50 + 200); // Varia√ß√£o de altura para as pedras
                    ctx.fillStyle = `rgb(${height}, ${height}, ${height})`;
                    ctx.beginPath();
                    ctx.arc(x + stoneSize / 2, y + stoneSize / 2, stoneSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function generateWoodPlankHeight(ctx, size) {
            const plankWidth = size / 6;
            for (let x = 0; x < size; x += plankWidth) {
                const height = Math.floor(Math.random() * 20 + 220);
                ctx.fillStyle = `rgb(${height}, ${height}, ${height})`;
                ctx.fillRect(x, 0, plankWidth, size);
                // Gaps are lower
                ctx.fillStyle = 'rgb(50, 50, 50)';
                ctx.fillRect(x - 1, 0, 2, size);
            }
        }
        
        function generateGrassHeight(ctx, size) {
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = Math.random() * 40;
                const height = Math.floor(Math.random() * 100 + 128);
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgb(${height}, ${height}, ${height})`);
                gradient.addColorStop(1, 'rgb(128, 128, 128)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // === GERA√á√ÉO PROCEDURAL DO CEN√ÅRIO MEDIEVAL ===

        // Fun√ß√£o principal que orquestra a cria√ß√£o da vila
        function createMedievalVillage() {
            createMainStreet();

            // Gerar pr√©dios ao longo da rua e arredores
            for (let i = 0; i < 30; i++) { // Aumentado para 30 pr√©dios
                const side = (Math.random() > 0.5) ? 1 : -1;
                const zPos = (Math.random() - 0.5) * 90;
                // Espalhar mais os pr√©dios
                const xPos = (8 + Math.random() * 25) * side;
                createMedievalBuilding({ x: xPos, y: 0, z: zPos });
            }

            // Adicionar um po√ßo perto do centro da vila
            createMedievalWell({ x: 2, y: 0, z: 15 });

            // Adicionar algumas linhas de cerca
            createFenceLine({ x: -20, z: -40 }, { x: -20, z: 40 });
            createFenceLine({ x: 20, z: -40 }, { x: 20, z: 40 });
            createFenceLine({ x: -20, z: -40 }, { x: 20, z: -40 });
            
            // Gerar mais NPCs
            for (let i = 0; i < 15; i++) { // Aumentado para 15 NPCs
                createNPC();
            }
        }

        // Cria a rua principal de paralelep√≠pedos
        function createMainStreet() {
            const streetTextures = generate3DTextures(512, 'cobblestone');
            const streetGeometry = new THREE.PlaneGeometry(10, 100);
            const streetMaterial = new THREE.MeshStandardMaterial({
                map: streetTextures.albedo,
                normalMap: streetTextures.normal,
                roughnessMap: streetTextures.roughness,
                displacementMap: streetTextures.height,
                displacementScale: 0.1
            });
            streetTextures.albedo.repeat.set(2, 20);
            streetTextures.normal.repeat.set(2, 20);
            streetTextures.roughness.repeat.set(2, 20);
            streetTextures.height.repeat.set(2, 20);

            const street = new THREE.Mesh(streetGeometry, streetMaterial);
            street.rotation.x = -Math.PI / 2;
            street.position.y = 0.05;
            street.receiveShadow = true;
            scene.add(street);
        }

        // Cria um pr√©dio medieval procedural reutiliz√°vel
        function createMedievalBuilding(options) {
            const building = new THREE.Group();
            building.position.set(options.x, options.y, options.z);

            const width = 6 + Math.random() * 4;
            const depth = 6 + Math.random() * 4;
            const height = 8 + Math.random() * 6;

            // Texturas
            const wallTextures = generate3DTextures(256, 'plaster_wall');
            const woodTextures = generate3DTextures(256, 'wood_planks');

            // Paredes
            const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTextures.albedo, normalMap: wallTextures.normal, roughnessMap: wallTextures.roughness });
            const wallMesh = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), wallMaterial);
            wallMesh.position.y = height / 2;
            wallMesh.castShadow = true;
            wallMesh.receiveShadow = true;
            building.add(wallMesh);
            
            // Estrutura de madeira
            const woodMaterial = new THREE.MeshStandardMaterial({ map: woodTextures.albedo, normalMap: woodTextures.normal, roughnessMap: woodTextures.roughness });
            // ... (c√≥digo para adicionar vigas de madeira nos cantos e bordas)

            // Telhado
            const roofHeight = height / 3;
            const roof = new THREE.Mesh(new THREE.ConeGeometry(Math.max(width, depth) * 0.7, roofHeight, 4), woodMaterial);
            roof.position.y = height + roofHeight / 2;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            building.add(roof);

            scene.add(building);
            return building;
        }

        // Cria um po√ßo medieval
        function createMedievalWell(position) {
            const well = new THREE.Group();
            well.position.set(position.x, position.y, position.z);

            const stoneTextures = generate3DTextures(128, 'cobblestone');
            const woodTextures = generate3DTextures(128, 'wood_planks');

            // Base do po√ßo
            const baseGeo = new THREE.CylinderGeometry(1.5, 1.5, 1, 12);
            const baseMat = new THREE.MeshStandardMaterial({
                map: stoneTextures.albedo,
                normalMap: stoneTextures.normal,
                displacementMap: stoneTextures.height,
                displacementScale: 0.1
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = 0.5;
            base.receiveShadow = true;
            base.castShadow = true;
            well.add(base);

            // Estrutura de madeira
            const woodMaterial = new THREE.MeshStandardMaterial({
                map: woodTextures.albedo,
                normalMap: woodTextures.normal
            });
            const postGeo = new THREE.BoxGeometry(0.2, 2.5, 0.2);
            const post1 = new THREE.Mesh(postGeo, woodMaterial);
            post1.position.set(-1.2, 1.75, 0); // Ajustado para ficar sobre a base
            post1.castShadow = true;
            well.add(post1);

            const post2 = new THREE.Mesh(postGeo, woodMaterial);
            post2.position.set(1.2, 1.75, 0); // Ajustado para ficar sobre a base
            post2.castShadow = true;
            well.add(post2);
            
            const crossbeam = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.2, 0.2), woodMaterial);
            crossbeam.position.set(0, 3, 0);
            crossbeam.castShadow = true;
            well.add(crossbeam);

            // Telhado
            const roofGeo = new THREE.CylinderGeometry(0, 2, 1, 4, 1);
            const roof = new THREE.Mesh(roofGeo, woodMaterial);
            roof.position.y = 3.5; // Ajustado para ficar sobre a viga
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            well.add(roof);

            scene.add(well);
        }

        // Cria uma linha de cerca procedural
        function createFenceLine(start, end) {
            const fence = new THREE.Group();
            const woodTextures = generate3DTextures(64, 'wood_planks');
            const woodMaterial = new THREE.MeshStandardMaterial({
                map: woodTextures.albedo,
                normalMap: woodTextures.normal
            });
            
            const startVec = new THREE.Vector3(start.x, 0, start.z);
            const endVec = new THREE.Vector3(end.x, 0, end.z);
            
            const length = startVec.distanceTo(endVec);
            const direction = new THREE.Vector3().subVectors(endVec, startVec).normalize();
            const count = Math.floor(length / 2);

            for (let i = 0; i <= count; i++) {
                const post = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 1.2),
                    woodMaterial
                );
                const pos = new THREE.Vector3().copy(startVec).add(direction.clone().multiplyScalar(i * 2));
                post.position.set(pos.x, 0.6, pos.z);
                post.castShadow = true;
                fence.add(post);
            }
            scene.add(fence);
        }

        // Cria um NPC simples
        function createNPC() {
            const npc = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.5, 1.0),
                new THREE.MeshStandardMaterial({ color: `hsl(${Math.random() * 360}, 50%, 50%)` })
            );
            npc.position.set(
                (Math.random() - 0.5) * 30, // √Årea de patrulha maior
                1,
                (Math.random() - 0.5) * 90
            );
            npc.castShadow = true;
            scene.add(npc);
            // L√≥gica de patrulha mais aleat√≥ria
            npc.userData.patrolTarget = new THREE.Vector3(
                (Math.random() - 0.5) * 30,
                1,
                (Math.random() - 0.5) * 90
            );
            npc.userData.patrolStart = new THREE.Vector3().copy(npc.position);
            npcs.push(npc);
        }
        
        // Criar a vila medieval
        createMedievalVillage();

        // Classe de Personagem Humanoide
        class HumanoidCharacter {
            constructor(scene, position = { x: 0, y: 0, z: 0 }) {
                this.scene = scene;
                this._position = position;
                this.group = new THREE.Group();
                this.bones = {};
                this.mixer = null;
                this.actions = {};
                this.currentAnimation = 'idle';
                this.clock = new THREE.Clock();
                this.fbxLoader = new FBXLoader();
                this.animationsLoaded = false;
                
                this.createCharacter();
                this.setupRig();
                this.setupMaterials();
                this.loadAnimations();
            }
            
            createCharacter() {
                // Cabe√ßa com textura de pele mais realista
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffdbac, // Cor de pele
                    roughness: 0.7,
                    metalness: 0.05,
                    emissive: 0x001100, // Leve brilho para efeito tecnol√≥gico
                    emissiveIntensity: 0.1
                });
                this.head = new THREE.Mesh(headGeometry, headMaterial);
                this.head.position.set(0, 1.7, 0);
                this.head.castShadow = true;
                this.group.add(this.head);
                
                // Torso com material g√≥tico hi-tech aprimorado
                const torsoGeometry = new THREE.CylinderGeometry(0.4, 0.3, 0.8, 12);
                const torsoMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a2a, // Cor mais escura
                    roughness: 0.3,
                    metalness: 0.8,
                    emissive: 0x001122, // Brilho azul tecnol√≥gico
                    emissiveIntensity: 0.3
                });
                this.torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                this.torso.position.set(0, 1.2, 0);
                this.torso.castShadow = true;
                this.group.add(this.torso);
                
                // Bra√ßos
                this.createArm(-0.5, 1.4, 0, 'left');  // Bra√ßo esquerdo
                this.createArm(0.5, 1.4, 0, 'right');  // Bra√ßo direito
                
                // Pernas
                this.createLeg(-0.2, 0.6, 0, 'left');   // Perna esquerda
                this.createLeg(0.2, 0.6, 0, 'right');   // Perna direita
                
                // P√©s
                this.createFoot(-0.2, 0.1, 0.1, 'left');  // P√© esquerdo
                this.createFoot(0.2, 0.1, 0.1, 'right');  // P√© direito
                
                // Detalhes g√≥tico hi-tech
                this.addTechDetails();
                
                // Posicionar personagem
                this.group.position.set(this._position.x, this._position.y, this._position.z);
                this.scene.add(this.group);
            }
            
            createArm(x, y, z, side) {
                // Ombro com material aprimorado
                const shoulderGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const shoulderMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffdbac,
                    roughness: 0.6,
                    metalness: 0.2,
                    emissive: 0x001100,
                    emissiveIntensity: 0.05
                });
                const shoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
                shoulder.position.set(x, y, z);
                shoulder.castShadow = true;
                this.group.add(shoulder);
                
                // Bra√ßo superior com textura de pele mais realista
                const upperArmGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.4, 8);
                const upperArmMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffdbac,
                    roughness: 0.6,
                    metalness: 0.1,
                    emissive: 0x001100,
                    emissiveIntensity: 0.05
                });
                const upperArm = new THREE.Mesh(upperArmGeometry, upperArmMaterial);
                upperArm.position.set(x, y - 0.2, z);
                upperArm.castShadow = true;
                this.group.add(upperArm);
                
                // Cotovelo
                const elbowGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const elbowMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffdbac,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const elbow = new THREE.Mesh(elbowGeometry, elbowMaterial);
                elbow.position.set(x, y - 0.4, z);
                elbow.castShadow = true;
                this.group.add(elbow);
                
                // Antebra√ßo
                const forearmGeometry = new THREE.CylinderGeometry(0.07, 0.08, 0.35, 8);
                const forearmMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffdbac,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const forearm = new THREE.Mesh(forearmGeometry, forearmMaterial);
                forearm.position.set(x, y - 0.6, z);
                forearm.castShadow = true;
                this.group.add(forearm);
                
                // M√£o
                const handGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const handMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffdbac,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const hand = new THREE.Mesh(handGeometry, handMaterial);
                hand.position.set(x, y - 0.8, z);
                hand.castShadow = true;
                this.group.add(hand);
                
                // Armadura g√≥tica no bra√ßo com detalhes aprimorados
                const armorGeometry = new THREE.CylinderGeometry(0.12, 0.14, 0.3, 8);
                const armorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x0a0a1a, // Mais escuro
                    roughness: 0.2,
                    metalness: 0.9,
                    emissive: 0x002244, // Brilho azul mais intenso
                    emissiveIntensity: 0.4
                });
                const armor = new THREE.Mesh(armorGeometry, armorMaterial);
                armor.position.set(x, y - 0.2, z);
                this.group.add(armor);
                
                // Detalhes da armadura - placas met√°licas
                const armorDetailGeometry = new THREE.CylinderGeometry(0.13, 0.15, 0.05, 8);
                const armorDetailMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffcc, // Ciano brilhante
                    roughness: 0.1,
                    metalness: 1.0,
                    emissive: 0x004433,
                    emissiveIntensity: 0.6
                });
                const armorDetail = new THREE.Mesh(armorDetailGeometry, armorDetailMaterial);
                armorDetail.position.set(x, y - 0.15, z);
                this.group.add(armorDetail);
                
                // Salvar refer√™ncias para anima√ß√£o
                this.bones[`${side}Shoulder`] = shoulder;
                this.bones[`${side}UpperArm`] = upperArm;
                this.bones[`${side}Elbow`] = elbow;
                this.bones[`${side}Forearm`] = forearm;
                this.bones[`${side}Hand`] = hand;
            }
            
            createLeg(x, y, z, side) {
                // Quadril
                const hipGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const hipMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a3a,
                    roughness: 0.6,
                    metalness: 0.4
                });
                const hip = new THREE.Mesh(hipGeometry, hipMaterial);
                hip.position.set(x, y, z);
                hip.castShadow = true;
                this.group.add(hip);
                
                // Coxa
                const thighGeometry = new THREE.CylinderGeometry(0.12, 0.15, 0.5, 8);
                const thighMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a3a,
                    roughness: 0.6,
                    metalness: 0.4
                });
                const thigh = new THREE.Mesh(thighGeometry, thighMaterial);
                thigh.position.set(x, y - 0.25, z);
                thigh.castShadow = true;
                this.group.add(thigh);
                
                // Joelho
                const kneeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const kneeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a3a,
                    roughness: 0.6,
                    metalness: 0.4
                });
                const knee = new THREE.Mesh(kneeGeometry, kneeMaterial);
                knee.position.set(x, y - 0.5, z);
                knee.castShadow = true;
                this.group.add(knee);
                
                // Canela
                const shinGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.4, 8);
                const shinMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a3a,
                    roughness: 0.6,
                    metalness: 0.4
                });
                const shin = new THREE.Mesh(shinGeometry, shinMaterial);
                shin.position.set(x, y - 0.7, z);
                shin.castShadow = true;
                this.group.add(shin);
                
                // Salvar refer√™ncias para anima√ß√£o
                this.bones[`${side}Hip`] = hip;
                this.bones[`${side}Thigh`] = thigh;
                this.bones[`${side}Knee`] = knee;
                this.bones[`${side}Shin`] = shin;
            }
            
            createFoot(x, y, z, side) {
                const footGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.4);
                const footMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a2a,
                    roughness: 0.4,
                    metalness: 0.6
                });
                const foot = new THREE.Mesh(footGeometry, footMaterial);
                foot.position.set(x, y, z);
                foot.castShadow = true;
                this.group.add(foot);
                
                this.bones[`${side}Foot`] = foot;
            }
            
            addTechDetails() {
                // Olhos brilhantes com efeito de scanning
                const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffcc,
                    emissive: 0x004433,
                    emissiveIntensity: 0.8
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.1, 1.75, 0.25);
                this.group.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.1, 1.75, 0.25);
                this.group.add(rightEye);
                
                // Peito com painel tecnol√≥gico avan√ßado
                const chestGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.1);
                const chestMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffcc,
                    emissive: 0x002211,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.9
                });
                const chest = new THREE.Mesh(chestGeometry, chestMaterial);
                chest.position.set(0, 1.3, 0.35);
                this.group.add(chest);
                
                // Linhas de energia no peito
                const energyLineGeometry = new THREE.BoxGeometry(0.25, 0.02, 0.01);
                const energyLineMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffcc,
                    emissive: 0x00ffcc,
                    emissiveIntensity: 1.0
                });
                for (let i = 0; i < 3; i++) {
                    const energyLine = new THREE.Mesh(energyLineGeometry, energyLineMaterial);
                    energyLine.position.set(0, 1.25 + i * 0.1, 0.4);
                    this.group.add(energyLine);
                }
                
                // Cintur√£o tecnol√≥gico com detalhes
                const beltGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.05, 12);
                const beltMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x0a0a1a,
                    roughness: 0.2,
                    metalness: 0.9,
                    emissive: 0x001122,
                    emissiveIntensity: 0.3
                });
                const belt = new THREE.Mesh(beltGeometry, beltMaterial);
                belt.position.set(0, 0.9, 0);
                this.group.add(belt);
                
                // Fivela do cintur√£o com display
                const buckleGeometry = new THREE.BoxGeometry(0.15, 0.08, 0.02);
                const buckleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffcc,
                    emissive: 0x004433,
                    emissiveIntensity: 0.8
                });
                const buckle = new THREE.Mesh(buckleGeometry, buckleMaterial);
                buckle.position.set(0, 0.9, 0.45);
                this.group.add(buckle);
                
                // Antenas/implantes na cabe√ßa
                const antennaGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.2, 6);
                const antennaMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffcc,
                    emissive: 0x004433,
                    emissiveIntensity: 0.6
                });
                
                const leftAntenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                leftAntenna.position.set(-0.15, 1.9, 0.1);
                leftAntenna.rotation.z = Math.PI / 6;
                this.group.add(leftAntenna);
                
                const rightAntenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                rightAntenna.position.set(0.15, 1.9, 0.1);
                rightAntenna.rotation.z = -Math.PI / 6;
                this.group.add(rightAntenna);
            }
            
            setupRig() {
                // Configurar mixer para anima√ß√µes
                this.mixer = new THREE.AnimationMixer(this.group);
                
                // Configurar bones para anima√ß√£o
                this.setupBoneHierarchy();
            }
            
            setupBoneHierarchy() {
                // Criar hierarquia de bones para anima√ß√£o
                this.bones.root = this.torso;
                this.bones.neck = this.head;
            }
            
            setupMaterials() {
                // Aplicar sombras a todos os elementos
                this.group.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
            }
            
            // Anima√ß√µes b√°sicas program√°ticas
            animateIdle() {
                const time = this.clock.getElapsedTime();
                this.torso.scale.y = 1 + Math.sin(time * 2) * 0.02;
            }
            
            animateRun() {
                const time = this.clock.getElapsedTime();
                
                // Movimento dos bra√ßos
                if (this.bones.leftUpperArm) {
                    this.bones.leftUpperArm.rotation.x = Math.sin(time * 8) * 0.5;
                }
                if (this.bones.rightUpperArm) {
                    this.bones.rightUpperArm.rotation.x = Math.sin(time * 8 + Math.PI) * 0.5;
                }
                
                // Movimento das pernas
                if (this.bones.leftThigh) {
                    this.bones.leftThigh.rotation.x = Math.sin(time * 8) * 0.3;
                }
                if (this.bones.rightThigh) {
                    this.bones.rightThigh.rotation.x = Math.sin(time * 8 + Math.PI) * 0.3;
                }
                
                // Movimento vertical do corpo
                this.group.position.y = 1.5 + Math.sin(time * 16) * 0.1;
            }
            
            animateAttack() {
                const time = this.clock.getElapsedTime();
                
                if (this.bones.rightUpperArm) {
                    this.bones.rightUpperArm.rotation.x = Math.sin(time * 20) * 0.8;
                }
                if (this.bones.rightForearm) {
                    this.bones.rightForearm.rotation.x = Math.sin(time * 20) * 0.4;
                }
            }
            
            loadAnimations() {
                // Usar apenas anima√ß√µes program√°ticas (FBX desabilitado)
                console.log('Usando anima√ß√µes program√°ticas (FBX desabilitado)');
                
                // Configurar mixer
                if (!this.mixer) {
                    this.mixer = new THREE.AnimationMixer(this.group);
                }
                
                // Criar anima√ß√µes program√°ticas simples
                this.actions.idle = this.createSimpleAction('idle');
                this.actions.run = this.createSimpleAction('run');
                this.actions.attack = this.createSimpleAction('attack');
                this.actions.hit = this.createSimpleAction('hit');
                this.actions.death = this.createSimpleAction('death');
                
                this.animationsLoaded = true;
                console.log('Todas as anima√ß√µes program√°ticas foram criadas!');
                this.playAnimation('idle');
            }
            
            createSimpleAction(animName) {
                // Criar uma a√ß√£o simples que n√£o faz nada (placeholder)
                const emptyClip = new THREE.AnimationClip(animName, 1, []);
                const action = this.mixer.clipAction(emptyClip);
                action.setLoop(THREE.LoopRepeat);
                action.clampWhenFinished = true;
                return action;
            }
            
            playAnimation(animName) {
                if (!this.animationsLoaded) {
                    console.log('Anima√ß√µes ainda n√£o carregadas, usando anima√ß√µes program√°ticas');
                    return;
                }
                
                if (this.currentAnimation === animName) return;
                
                // Parar anima√ß√£o atual
                if (this.actions[this.currentAnimation]) {
                    this.actions[this.currentAnimation].fadeOut(0.5);
                }
                
                // Iniciar nova anima√ß√£o
                if (this.actions[animName]) {
                    this.actions[animName].reset().fadeIn(0.5).play();
                    this.currentAnimation = animName;
                    console.log(`Tocando anima√ß√£o: ${animName}`);
                } else {
                    console.warn(`Anima√ß√£o ${animName} n√£o encontrada`);
                }
            }
            
            update() {
                if (this.mixer) {
                    this.mixer.update(this.clock.getDelta());
                }
            }
            
            // Getters para compatibilidade
            get position() {
                return this.group.position;
            }
            
            get rotation() {
                return this.group.rotation;
            }
            
            get scale() {
                return this.group.scale;
            }
        }

        // Criar personagem humanoide
        const player = new HumanoidCharacter(scene, { x: 0, y: 0, z: 0 });

        // === SISTEMA DO EDITOR DE MAPAS ===
        
        // Inicializar loaders para carregar assets
        const gltfLoader = new GLTFLoader();
        const fbxLoader = new FBXLoader();
        
        // Lista de assets dispon√≠veis (FBX + GLB) - Limpa para o tema medieval
        const fbxAssets = [];
        const glbAssets = [];
        const assetList = [];
        
        // Cores dos pinc√©is de terreno
        const brushColors = {
            grass: 0x2a3a2a,
            dirt: 0x8B4513,
            stone: 0x696969,
            metal: 0x708090
        };
        
        // Fun√ß√£o para criar modelos program√°ticos
        function createProgrammaticAsset(assetName) {
            let geometry, material, mesh;
            
            switch(assetName) {
                case 'parede_pedra_01':
                    geometry = new THREE.BoxGeometry(2, 4, 0.3);
                    material = new THREE.MeshStandardMaterial({ 
                        color: 0x8B7355,
                        roughness: 0.8,
                        metalness: 0.1
                    });
                    mesh = new THREE.Mesh(geometry, material);
                    break;
                    
                case 'porta_metalica':
                    geometry = new THREE.BoxGeometry(1, 2.5, 0.1);
                    material = new THREE.MeshStandardMaterial({ 
                        color: 0x2a2a3a,
                        roughness: 0.3,
                        metalness: 0.8,
                        emissive: 0x001122
                    });
                    mesh = new THREE.Mesh(geometry, material);
                    break;
                    
                case 'janela_simples':
                    geometry = new THREE.BoxGeometry(1.5, 1.5, 0.1);
                    material = new THREE.MeshStandardMaterial({ 
                        color: 0x87CEEB,
                        roughness: 0.1,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0.7
                    });
                    mesh = new THREE.Mesh(geometry, material);
                    break;
                    
                case 'mesa_metalica':
                    // Mesa com pernas
                    const tableGroup = new THREE.Group();
                    
                    // Tampo da mesa
                    const tableTopGeometry = new THREE.BoxGeometry(2, 0.1, 1);
                    const tableTopMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a2a,
                        roughness: 0.2,
                        metalness: 0.9
                    });
                    const tableTop = new THREE.Mesh(tableTopGeometry, tableTopMaterial);
                    tableTop.position.y = 0.8;
                    tableGroup.add(tableTop);
                    
                    // Pernas da mesa
                    const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.6);
                    const legMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x2a2a3a,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    
                    for (let i = 0; i < 4; i++) {
                        const leg = new THREE.Mesh(legGeometry, legMaterial);
                        const angle = (i * Math.PI) / 2;
                        leg.position.set(
                            Math.cos(angle) * 0.8,
                            0,
                            Math.sin(angle) * 0.3
                        );
                        tableGroup.add(leg);
                    }
                    
                    mesh = tableGroup;
                    break;
                    
                case 'cadeira_futurista':
                    // Cadeira futurista
                    const chairGroup = new THREE.Group();
                    
                    // Assento
                    const seatGeometry = new THREE.BoxGeometry(0.8, 0.1, 0.8);
                    const seatMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00ffcc,
                        roughness: 0.2,
                        metalness: 0.8,
                        emissive: 0x002211
                    });
                    const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                    seat.position.y = 0.4;
                    chairGroup.add(seat);
                    
                    // Encosto
                    const backGeometry = new THREE.BoxGeometry(0.8, 1, 0.1);
                    const backMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00ffcc,
                        roughness: 0.2,
                        metalness: 0.8,
                        emissive: 0x002211
                    });
                    const back = new THREE.Mesh(backGeometry, backMaterial);
                    back.position.set(0, 0.9, -0.35);
                    chairGroup.add(back);
                    
                    // Pernas
                    const chairLegGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.8);
                    const chairLegMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x2a2a3a,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    
                    for (let i = 0; i < 4; i++) {
                        const leg = new THREE.Mesh(chairLegGeometry, chairLegMaterial);
                        const angle = (i * Math.PI) / 2;
                        leg.position.set(
                            Math.cos(angle) * 0.3,
                            0,
                            Math.sin(angle) * 0.3
                        );
                        chairGroup.add(leg);
                    }
                    
                    mesh = chairGroup;
                    break;
                    
                default:
                    // Asset padr√£o
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    material = new THREE.MeshStandardMaterial({ 
                        color: 0x666666,
                        roughness: 0.5,
                        metalness: 0.5
                    });
                    mesh = new THREE.Mesh(geometry, material);
            }
            
            // Aplicar sombras
            mesh.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            return mesh;
        }
        
        // Fun√ß√£o para carregar assets - Desabilitada para o tema medieval
        function loadAssets() {
            const assetListElement = document.getElementById('asset-list');
            if (assetListElement) {
                assetListElement.innerHTML = '<p style="color: #666;">Assets do editor desabilitados no modo medieval.</p>';
            }
            console.log('Carregamento de assets do editor ignorado.');
        }
        
        // Fun√ß√£o para selecionar asset para coloca√ß√£o
        function selectAsset(assetName) {
            if (assetLibrary[assetName]) {
                // Clonar o asset
                const clone = assetLibrary[assetName].clone();
                
                // Posicionar na frente da c√¢mera
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                clone.position.copy(camera.position).add(direction.multiplyScalar(2));
                clone.position.y = 0; // Alinhar ao ch√£o
                clone.name = `asset_${Date.now()}`;
                
                // Aplicar sombras
                clone.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // Adicionar √† cena
                scene.add(clone);
                placedObjects.push(clone);
                
                // Selecionar automaticamente o objeto colocado
                selectObject(clone);
                
                console.log(`Asset ${assetName} colocado e selecionado`);
            }
        }
        
        // Fun√ß√£o para alternar modo de edi√ß√£o
        function toggleEditMode() {
            isEditMode = !isEditMode;
            const editorUI = document.getElementById('editor-ui');
            const infoPanel = document.getElementById('info-panel');
            
            if (isEditMode) {
                // Entrar no modo de edi√ß√£o
                editorUI.style.display = 'block';
                infoPanel.style.display = 'none';
                if (player && player.group) {
                    player.group.visible = false; // Esconder personagem
                }
                
                // Adicionar grid
                if (!gridHelper) {
                    gridHelper = new THREE.GridHelper(200, 50, 0x00ffcc, 0x004433);
                    scene.add(gridHelper);
                }
                
                // Configurar c√¢mera livre na posi√ß√£o do personagem
                if (player && player.position) {
                    camera.position.copy(player.position).add(new THREE.Vector3(0, 5, 5));
                    camera.lookAt(player.position);
                } else {
                    camera.position.set(10, 10, 10);
                    camera.lookAt(0, 0, 0);
                }
                
                // Mostrar pain√©is do editor
                document.getElementById('toolbar').style.display = 'flex';
                document.getElementById('asset-library').style.display = 'block';
                document.getElementById('inspector').style.display = 'block';
                
                console.log('Modo de edi√ß√£o ativado');
            } else {
                // Sair do modo de edi√ß√£o
                editorUI.style.display = 'none';
                infoPanel.style.display = 'block';
                if (player && player.group) {
                    player.group.visible = true; // Mostrar personagem
                }
                
                // Remover grid
                if (gridHelper) {
                    scene.remove(gridHelper);
                }
                
                // Esconder pain√©is do editor
                document.getElementById('toolbar').style.display = 'none';
                document.getElementById('asset-library').style.display = 'none';
                document.getElementById('inspector').style.display = 'none';
                document.getElementById('terrain-brushes').style.display = 'none';
                
                // Limpar sele√ß√£o
                if (selectedObject) {
                    deselectObject();
                }
                
                console.log('Modo de edi√ß√£o desativado');
            }
        }
        
        // Fun√ß√£o para selecionar objeto
        function selectObject(object) {
            if (selectedObject) {
                deselectObject();
            }
            
            selectedObject = object;
            
            // Destacar objeto selecionado
            const boxHelper = new THREE.BoxHelper(object, 0x00ffcc);
            boxHelper.name = 'selectionHelper';
            scene.add(boxHelper);
            
            // Configurar transform controls
            if (transformControls) {
                scene.remove(transformControls);
            }
            
            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.attach(object);
            transformControls.setMode(currentTool);
            scene.add(transformControls);
            
            // Event listeners para transform controls
            transformControls.addEventListener('change', () => {
                updateInspector();
            });
            
            // Atualizar inspetor
            updateInspector();
            
            console.log('Objeto selecionado:', object.name);
        }
        
        // Fun√ß√£o para deselecionar objeto
        function deselectObject() {
            if (selectedObject) {
                // Remover highlight
                const helper = scene.getObjectByName('selectionHelper');
                if (helper) {
                    scene.remove(helper);
                }
                
                // Remover transform controls
                if (transformControls) {
                    scene.remove(transformControls);
                    transformControls = null;
                }
                
                selectedObject = null;
                updateInspector();
            }
        }
        
        // Fun√ß√£o para atualizar inspetor
        function updateInspector() {
            const inspector = document.getElementById('object-properties');
            
            if (!selectedObject) {
                inspector.innerHTML = '<p style="color: #666;">Nenhum objeto selecionado</p>';
                return;
            }
            
            const pos = selectedObject.position;
            const rot = selectedObject.rotation;
            const scale = selectedObject.scale;
            
            inspector.innerHTML = `
                <div class="property-group">
                    <label>Nome:</label>
                    <input type="text" value="${selectedObject.name || 'Sem nome'}" readonly>
                </div>
                <div class="property-group">
                    <label>Posi√ß√£o X:</label>
                    <input type="number" value="${pos.x.toFixed(2)}" step="0.1">
                </div>
                <div class="property-group">
                    <label>Posi√ß√£o Y:</label>
                    <input type="number" value="${pos.y.toFixed(2)}" step="0.1">
                </div>
                <div class="property-group">
                    <label>Posi√ß√£o Z:</label>
                    <input type="number" value="${pos.z.toFixed(2)}" step="0.1">
                </div>
                <div class="property-group">
                    <label>Rotacionar X:</label>
                    <input type="number" value="${(rot.x * 180 / Math.PI).toFixed(1)}" step="1">
                </div>
                <div class="property-group">
                    <label>Rotacionar Y:</label>
                    <input type="number" value="${(rot.y * 180 / Math.PI).toFixed(1)}" step="1">
                </div>
                <div class="property-group">
                    <label>Rotacionar Z:</label>
                    <input type="number" value="${(rot.z * 180 / Math.PI).toFixed(1)}" step="1">
                </div>
                <div class="property-group">
                    <label>Escala X:</label>
                    <input type="number" value="${scale.x.toFixed(2)}" step="0.1">
                </div>
                <div class="property-group">
                    <label>Escala Y:</label>
                    <input type="number" value="${scale.y.toFixed(2)}" step="0.1">
                </div>
                <div class="property-group">
                    <label>Escala Z:</label>
                    <input type="number" value="${scale.z.toFixed(2)}" step="0.1">
                </div>
            `;
        }
        
        // Fun√ß√£o para pintar terreno
        function paintTerrain(intersection) {
            if (currentTool !== 'paint') return;
            
            const ground = scene.getObjectByName('ground');
            if (!ground || !ground.geometry.attributes.color) return;
            
            const colors = ground.geometry.attributes.color.array;
            const position = ground.geometry.attributes.position;
            const brushColor = new THREE.Color(brushColors[currentBrush]);
            
            // Encontrar v√©rtices pr√≥ximos ao ponto de intersec√ß√£o
            const brushRadius = 5;
            const brushRadiusSquared = brushRadius * brushRadius;
            
            for (let i = 0; i < position.count; i++) {
                const vertex = new THREE.Vector3(
                    position.getX(i),
                    position.getY(i),
                    position.getZ(i)
                );
                
                const distance = intersection.point.distanceTo(vertex);
                
                if (distance < brushRadius) {
                    const intensity = 1 - (distance / brushRadius);
                    const currentColor = new THREE.Color(
                        colors[i * 3],
                        colors[i * 3 + 1],
                        colors[i * 3 + 2]
                    );
                    
                    // Misturar cores
                    const newColor = currentColor.clone().lerp(brushColor, intensity * 0.3);
                    
                    colors[i * 3] = newColor.r;
                    colors[i * 3 + 1] = newColor.g;
                    colors[i * 3 + 2] = newColor.b;
                }
            }
            
            ground.geometry.attributes.color.needsUpdate = true;
        }
        
        // Carregar assets ao inicializar
        console.log('Inicializando assets...');
        loadAssets();

        // Sistema de controles
        const keysPressed = {};
        let isRightMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraOffset = new THREE.Vector3(0, 5, 10);
        let playerRotation = 0;
        let cameraDistance = 10;
        let cameraHeight = 5;
        let isFirstPerson = false;
        let isFlying = false;
        let playerVelocity = new THREE.Vector3(0, 0, 0);
        let isRunning = false;

        // Event listeners para controles
        document.addEventListener('keydown', (e) => { 
            keysPressed[e.key.toLowerCase()] = true; 
            
            // Alternar entre primeira e terceira pessoa com a tecla V
            if (e.key.toLowerCase() === 'v') {
                isFirstPerson = !isFirstPerson;
                if (isFirstPerson) {
                    cameraDistance = 0;
                    cameraHeight = 1.5;
                } else {
                    cameraDistance = 10;
                    cameraHeight = 5;
                }
            }
            
            // Alternar modo de voo com a tecla F
            if (e.key.toLowerCase() === 'f') {
                isFlying = !isFlying;
                if (isFlying) {
                    playerVelocity.y = 0; // Parar movimento vertical ao ativar voo
                }
                // Atualizar indicador visual
                const flyingStatus = document.getElementById('flying-status');
                if (flyingStatus) {
                    flyingStatus.style.display = isFlying ? 'block' : 'none';
                }
            }
            
            // Detectar SHIFT para corrida
            if (e.key === 'Shift') {
                isRunning = true;
                // Atualizar indicador visual
                const runningStatus = document.getElementById('running-status');
                if (runningStatus) {
                    runningStatus.style.display = 'block';
                }
            }
            
            // Ataque com a tecla E
            if (e.key.toLowerCase() === 'e') {
                if (player.animationsLoaded) {
                    player.playAnimation('attack');
                    // Voltar para idle ap√≥s 2 segundos
                    setTimeout(() => {
                        if (isFlying) {
                            player.playAnimation('idle');
                        } else if (isRunning && (keysPressed['w'] || keysPressed['a'] || keysPressed['s'] || keysPressed['d'])) {
                            player.playAnimation('run');
                        } else if (keysPressed['w'] || keysPressed['a'] || keysPressed['s'] || keysPressed['d']) {
                            player.playAnimation('run');
                        } else {
                            player.playAnimation('idle');
                        }
                    }, 2000);
                } else {
                    player.animateAttack();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => { 
            keysPressed[e.key.toLowerCase()] = false; 
            
            // Detectar quando soltar SHIFT
            if (e.key === 'Shift') {
                isRunning = false;
                // Atualizar indicador visual
                const runningStatus = document.getElementById('running-status');
                if (runningStatus) {
                    runningStatus.style.display = 'none';
                }
            }
        });

        // Prevenir menu de contexto
        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // Controles do mouse para c√¢mera
        document.addEventListener('mousedown', (e) => { 
            if (e.button === 2) { 
                isRightMouseDown = true; 
                previousMousePosition = { x: e.clientX, y: e.clientY }; 
            } 
        });

        document.addEventListener('mouseup', (e) => { 
            if (e.button === 2) { 
                isRightMouseDown = false; 
            } 
        });


        // === EVENT LISTENERS DO EDITOR ===
        
        // Toggle do modo de edi√ß√£o
        document.getElementById('toggle-editor').addEventListener('click', () => {
            console.log('Bot√£o do editor clicado');
            toggleEditMode();
        });
        
        // Ferramentas da barra superior
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                // Remover classe active de todos os bot√µes
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                // Adicionar classe active ao bot√£o clicado
                e.target.classList.add('active');
                
                currentTool = e.target.dataset.tool;
                
                // Mostrar/ocultar painel de pinc√©is
                const terrainBrushes = document.getElementById('terrain-brushes');
                if (currentTool === 'paint') {
                    terrainBrushes.style.display = 'block';
                } else {
                    terrainBrushes.style.display = 'none';
                }
                
                // Atualizar transform controls se houver objeto selecionado
                if (transformControls && selectedObject) {
                    transformControls.setMode(currentTool);
                }
                
                console.log('Ferramenta selecionada:', currentTool);
            });
        });
        
        // Pinc√©is de terreno
        document.querySelectorAll('.brush-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                // Remover classe active de todos os pinc√©is
                document.querySelectorAll('.brush-btn').forEach(b => b.classList.remove('active'));
                // Adicionar classe active ao pincel clicado
                e.target.classList.add('active');
                
                currentBrush = e.target.dataset.brush;
                console.log('Pincel selecionado:', currentBrush);
            });
        });
        
        // Controles do mouse para o editor
        document.addEventListener('mousedown', (e) => {
            if (!isEditMode) return;
            
            if (e.button === 0) { // Bot√£o esquerdo
                // Raycasting para sele√ß√£o/coloca√ß√£o
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                if (isPlacingAsset && assetToPlace) {
                    // Modo de coloca√ß√£o de asset
                    const intersects = raycaster.intersectObjects([ground]);
                    if (intersects.length > 0) {
                        const intersection = intersects[0];
                        const clone = assetToPlace.clone();
                        clone.position.copy(intersection.point);
                        clone.position.y = 0; // Alinhar ao ch√£o
                        clone.name = `asset_${Date.now()}`;
                        
                        // Aplicar sombras
                        clone.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        scene.add(clone);
                        placedObjects.push(clone);
                        
                        console.log('Asset colocado:', clone.name);
                    }
                } else if (currentTool === 'paint') {
                    // Modo de pintura
                    const intersects = raycaster.intersectObjects([ground]);
                    if (intersects.length > 0) {
                        paintTerrain(intersects[0]);
                    }
                } else {
                    // Modo de sele√ß√£o
                    const intersects = raycaster.intersectObjects(placedObjects);
                    if (intersects.length > 0) {
                        selectObject(intersects[0].object);
                    } else {
                        deselectObject();
                    }
                }
            }
        });
        
        // Controles de c√¢mera livre no modo de edi√ß√£o
        document.addEventListener('keydown', (e) => {
            if (!isEditMode) return;
            
            const moveSpeed = 0.5;
            const direction = new THREE.Vector3();
            
            // Movimento da c√¢mera
            if (keysPressed['w']) direction.z -= moveSpeed;
            if (keysPressed['s']) direction.z += moveSpeed;
            if (keysPressed['a']) direction.x -= moveSpeed;
            if (keysPressed['d']) direction.x += moveSpeed;
            if (keysPressed['q']) direction.y -= moveSpeed;
            if (keysPressed['e']) direction.y += moveSpeed;
            
            // Aplicar rota√ß√£o da c√¢mera ao movimento
            direction.applyQuaternion(camera.quaternion);
            camera.position.add(direction);
        });
        
        // Controles de c√¢mera com mouse (modo jogo e edi√ß√£o)
        document.addEventListener('mousemove', (e) => {
            if (!isRightMouseDown) return;
            
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            
            if (isEditMode) {
                // Modo edi√ß√£o: c√¢mera livre
                const yAxis = new THREE.Vector3(0, 1, 0);
                camera.rotateOnAxis(yAxis, -deltaX * 0.005);
                
                const xAxis = new THREE.Vector3().crossVectors(yAxis, camera.getWorldDirection(new THREE.Vector3())).normalize();
                camera.rotateOnAxis(xAxis, -deltaY * 0.005);
            } else {
                // Modo jogo: c√¢mera orbital
                const yAxis = new THREE.Vector3(0, 1, 0);
                cameraOffset.applyAxisAngle(yAxis, -deltaX * 0.005);
                
                const xAxis = new THREE.Vector3().crossVectors(yAxis, cameraOffset).normalize();
                cameraOffset.applyAxisAngle(xAxis, -deltaY * 0.005);
                
                // Limitar rota√ß√£o vertical
                if (cameraOffset.y < 2) cameraOffset.y = 2;
                if (cameraOffset.y > 15) cameraOffset.y = 15;
            }
            
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        // Loop de anima√ß√£o
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            // === L√ìGICA DO EDITOR ===
            if (isEditMode) {
                // No modo de edi√ß√£o, apenas atualizar transform controls
                if (transformControls && typeof transformControls.update === 'function') {
                    transformControls.update();
                }
                
                // Renderizar cena
                renderer.render(scene, camera);
                return;
            }
            
            // === L√ìGICA DO JOGO (modo normal) ===
            
            // Calcular velocidade base
            let baseSpeed = 5;
            if (isRunning) {
                baseSpeed *= 2; // Dobrar velocidade ao correr
            }
            const moveSpeed = baseSpeed * delta;
            
            // Movimento do personagem relativo √† c√¢mera
            const moveVector = new THREE.Vector3();
            
            // Obter dire√ß√£o da c√¢mera
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            // Para movimento no ch√£o, ignorar componente Y
            if (!isFlying) {
                cameraDirection.y = 0;
            }
            cameraDirection.normalize();
            
            // Dire√ß√£o perpendicular √† c√¢mera (para movimento lateral)
            const rightDirection = new THREE.Vector3();
            rightDirection.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));
            rightDirection.normalize();
            
            // Movimento horizontal (WASD)
            if (keysPressed['w']) {
                moveVector.add(cameraDirection.clone().multiplyScalar(moveSpeed));
            }
            if (keysPressed['s']) {
                moveVector.add(cameraDirection.clone().multiplyScalar(-moveSpeed));
            }
            if (keysPressed['a']) {
                moveVector.add(rightDirection.clone().multiplyScalar(-moveSpeed));
            }
            if (keysPressed['d']) {
                moveVector.add(rightDirection.clone().multiplyScalar(moveSpeed));
            }
            
            // Movimento vertical (apenas no modo voo)
            if (isFlying) {
                if (keysPressed[' ']) { // Espa√ßo para subir
                    moveVector.y += moveSpeed;
                }
                if (keysPressed['c']) { // C para descer
                    moveVector.y -= moveSpeed;
                }
            } else {
                // No ch√£o, aplicar gravidade
                playerVelocity.y -= 20 * delta; // Gravidade
                moveVector.y = playerVelocity.y * delta;
                
                // Verificar colis√£o com o ch√£o
                if (player.position.y + moveVector.y <= 1.5) {
                    player.position.y = 1.5;
                    playerVelocity.y = 0;
                    moveVector.y = 0;
                }
                
                // Pulo (apenas no ch√£o)
                if (keysPressed[' '] && player.position.y <= 1.6) {
                    playerVelocity.y = 15; // For√ßa do pulo
                }
            }
            
            // Aplicar movimento
            player.position.add(moveVector);
            
            // Rotacionar personagem na dire√ß√£o do movimento (apenas horizontal)
            if (moveVector.x !== 0 || moveVector.z !== 0) {
                const moveDirection = new THREE.Vector3(moveVector.x, 0, moveVector.z).normalize();
                playerRotation = Math.atan2(moveDirection.x, moveDirection.z);
                player.rotation.y = playerRotation;
            }
            
            // Atualizar anima√ß√µes do personagem
            if (player.animationsLoaded) {
                // Usar anima√ß√µes FBX quando dispon√≠veis
                if (isFlying) {
                    player.playAnimation('idle');
                } else if (isRunning && (keysPressed['w'] || keysPressed['a'] || keysPressed['s'] || keysPressed['d'])) {
                    player.playAnimation('run');
                } else if (keysPressed['w'] || keysPressed['a'] || keysPressed['s'] || keysPressed['d']) {
                    player.playAnimation('run');
                } else {
                    player.playAnimation('idle');
                }
            } else {
                // Usar anima√ß√µes program√°ticas como fallback
                if (isFlying) {
                    player.animateIdle();
                } else if (isRunning && (keysPressed['w'] || keysPressed['a'] || keysPressed['s'] || keysPressed['d'])) {
                    player.animateRun();
                } else if (keysPressed['w'] || keysPressed['a'] || keysPressed['s'] || keysPressed['d']) {
                    player.animateRun();
                } else {
                    player.animateIdle();
                }
            }
            
            // Atualizar personagem
            player.update();
            
            // Atualizar posi√ß√£o da c√¢mera
            if (isFirstPerson) {
                // Primeira pessoa: c√¢mera na posi√ß√£o do personagem
                camera.position.copy(player.position);
                camera.position.y += cameraHeight;
                
                // Olhar na dire√ß√£o da c√¢mera
                const lookDirection = new THREE.Vector3();
                camera.getWorldDirection(lookDirection);
                const lookTarget = player.position.clone().add(lookDirection.multiplyScalar(10));
                camera.lookAt(lookTarget);
            } else {
                // Terceira pessoa: c√¢mera atr√°s do personagem
                let targetCameraPosition = player.position.clone().add(cameraOffset);
                
                // Verificar se a c√¢mera n√£o est√° abaixo do ch√£o
                if (targetCameraPosition.y < 1) {
                    targetCameraPosition.y = 1;
                }
                
                camera.position.lerp(targetCameraPosition, 0.2);
                camera.lookAt(player.position);
            }
            
            // Renderizar cena
            renderer.render(scene, camera);
        }

        // Redimensionamento da janela
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Iniciar anima√ß√£o
        animate();
    </script>
</body>
</html>
