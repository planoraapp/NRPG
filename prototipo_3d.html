<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prot√≥tipo 3D - RPG G√≥tico Hi-Tech</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Courier New', Courier, monospace; 
        }
        canvas { 
            display: block; 
        }
        #info-panel { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            padding: 15px; 
            background-color: rgba(0, 0, 0, 0.7); 
            color: #00ffcc; 
            border: 2px solid #00ffcc; 
            border-radius: 8px; 
            font-size: 14px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
        }
        #info-panel h3 {
            margin: 0 0 10px 0;
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }
        #info-panel p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h3>üåô RPG G√≥tico Hi-Tech - Prot√≥tipo</h3>
        <p><strong>Movimento:</strong> W, A, S, D</p>
        <p><strong>Corrida:</strong> SHIFT + WASD</p>
        <p><strong>Voo:</strong> F (ativar/desativar)</p>
        <p><strong>Voo:</strong> Espa√ßo (subir) / C (descer)</p>
        <p><strong>Pulo:</strong> Espa√ßo (no ch√£o)</p>
        <p><strong>C√¢mera:</strong> Bot√£o direito + Arrastar</p>
        <p><strong>Vis√£o:</strong> V (1¬™/3¬™ pessoa)</p>
        <p><strong>Texturas:</strong> CyberSample 4K + VoxelCity</p>
        <p><strong>Elementos:</strong> Pr√©dios, Estradas, Props Urbanos</p>
        <p><strong>Atmosfera:</strong> Tecno-Medieval + Retr√¥-Futurista</p>
        <div id="status-indicators">
            <p id="flying-status" style="color: #ff6b6b; display: none;">‚úàÔ∏è MODO VOO ATIVO</p>
            <p id="running-status" style="color: #00ffcc; display: none;">üèÉ CORRENDO</p>
        </div>
    </div>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    { 
        "imports": { 
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js" 
        } 
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';

        // Inicializa√ß√£o da cena
        const scene = new THREE.Scene();
        
        // Inicializar texture loader
        const textureLoader = new THREE.TextureLoader();
        
        // Configura√ß√£o da n√©voa para atmosfera sombria
        scene.fog = new THREE.Fog(0x0a0a1a, 20, 100);
        
        // Configura√ß√£o da c√¢mera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        
        // Configura√ß√£o do renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x0a0a1a);
        document.body.appendChild(renderer.domElement);

        // Ilumina√ß√£o ambiente (tons azulados)
        const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
        scene.add(ambientLight);

        // Luz direcional principal
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -25;
        directionalLight.shadow.camera.right = 25;
        directionalLight.shadow.camera.top = 25;
        directionalLight.shadow.camera.bottom = -25;
        scene.add(directionalLight);

        // Luzes de neon para atmosfera cyberpunk
        const neonLight1 = new THREE.PointLight(0x00ffcc, 0.5, 30);
        neonLight1.position.set(15, 8, 15);
        scene.add(neonLight1);

        const neonLight2 = new THREE.PointLight(0xff6b6b, 0.4, 25);
        neonLight2.position.set(-20, 6, -10);
        scene.add(neonLight2);

        const neonLight3 = new THREE.PointLight(0x9d4edd, 0.3, 20);
        neonLight3.position.set(0, 10, -25);
        scene.add(neonLight3);

        // Ch√£o do cen√°rio com textura procedural
        const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
        
        // Criar textura procedural para o ch√£o
        const groundTexture = new THREE.DataTexture(
            new Uint8Array(256 * 256 * 3), 256, 256, THREE.RGBFormat
        );
        
        // Gerar padr√£o de piso tecnol√≥gico
        const data = groundTexture.image.data;
        for (let i = 0; i < data.length; i += 3) {
            const x = (i / 3) % 256;
            const y = Math.floor((i / 3) / 256);
            
            // Padr√£o de hex√°gonos e linhas
            const hexPattern = Math.sin(x * 0.1) * Math.cos(y * 0.1) > 0.3;
            const linePattern = (x % 32 < 2) || (y % 32 < 2);
            
            if (hexPattern) {
                data[i] = 20;     // R
                data[i + 1] = 25; // G  
                data[i + 2] = 35; // B
            } else if (linePattern) {
                data[i] = 0;      // R
                data[i + 1] = 255; // G
                data[i + 2] = 204; // B
            } else {
                data[i] = 15;     // R
                data[i + 1] = 20; // G
                data[i + 2] = 30; // B
            }
        }
        groundTexture.needsUpdate = true;
        
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            map: groundTexture,
            color: 0x1a1a2a,
            roughness: 0.6,
            metalness: 0.3,
            emissive: 0x001122
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Carregar texturas de pr√©dios cyberpunk
        const cyberTextures = {};
        
        // Fun√ß√£o para carregar texturas com fallback
        function loadCyberTexture(path, name) {
            const texture = textureLoader.load(
                path,
                () => console.log(`Textura carregada: ${name}`),
                undefined,
                (error) => {
                    console.warn(`Erro ao carregar ${name}:`, error);
                    // Usar textura procedural como fallback
                    return createProceduralTexture(256, 'building');
                }
            );
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        // Carregar texturas de pr√©dios
        cyberTextures.buildings1 = loadCyberTexture('CyberSample/FreeSample/Textures/T_Buildings_001Diffuse- 4K.png', 'Buildings 1');
        cyberTextures.buildings2 = loadCyberTexture('CyberSample/FreeSample/Textures/T_Buildings_002Diffuse- 4K.png', 'Buildings 2');
        cyberTextures.buildingsEmissive1 = loadCyberTexture('CyberSample/FreeSample/Textures/BAKE_Buildings_001Emissive- 4K.png', 'Buildings Emissive 1');
        cyberTextures.buildingsEmissive2 = loadCyberTexture('CyberSample/FreeSample/Textures/BAKE_Buildings_002Emissive- 4K.png', 'Buildings Emissive 2');
        cyberTextures.roads = loadCyberTexture('CyberSample/FreeSample/Textures/T_RoadsDiffuse- 4K.png', 'Roads');
        cyberTextures.roadsEmissive = loadCyberTexture('CyberSample/FreeSample/Textures/BAKE_RoadsEmissive- 4K.png', 'Roads Emissive');
        cyberTextures.props = loadCyberTexture('CyberSample/FreeSample/Textures/T_PropsDiffuse- 4K.png', 'Props');
        cyberTextures.propsEmissive = loadCyberTexture('CyberSample/FreeSample/Textures/BAKE_PropsEmissive- 4K.png', 'Props Emissive');
        
        // Carregar texturas VoxelCity
        cyberTextures.voxelBuildings1 = loadCyberTexture('CyberSample/FreeSample/Textures/VoxelCity_CompositeBuildings_Optimized-0_diffuse.png', 'Voxel Buildings 1');
        cyberTextures.voxelBuildings2 = loadCyberTexture('CyberSample/FreeSample/Textures/VoxelCity_CompositeBuildings_Optimized-2_diffuse.png', 'Voxel Buildings 2');
        cyberTextures.voxelBuildings3 = loadCyberTexture('CyberSample/FreeSample/Textures/VoxelCity_CompositeBuildings_Optimized-4_diffuse.png', 'Voxel Buildings 3');
        cyberTextures.voxelColor = loadCyberTexture('CyberSample/FreeSample/Textures/VoxelCity_CompositeBuildings_Optimized-4_Color.png', 'Voxel Color');
        
        // Fun√ß√£o para criar textura procedural como fallback
        function createProceduralTexture(size, type) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Base escura
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(0, 0, size, size);
            
            // Adicionar padr√µes baseados no tipo
            if (type === 'building') {
                // Padr√£o de janelas
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const w = Math.random() * 20 + 10;
                    const h = Math.random() * 30 + 15;
                    
                    ctx.fillStyle = Math.random() > 0.5 ? '#00ffcc' : '#ff6b6b';
                    ctx.fillRect(x, y, w, h);
                }
                
                // Linhas estruturais
                ctx.strokeStyle = '#333343';
                ctx.lineWidth = 2;
                for (let i = 0; i < 20; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * size / 20);
                    ctx.lineTo(size, i * size / 20);
                    ctx.stroke();
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Fun√ß√£o para criar pr√©dio g√≥tico hi-tech
        function createGothicTechBuilding(x, z, width, height, depth) {
            const buildingGroup = new THREE.Group();
            
            // Escolher textura aleat√≥ria
            const textureIndex = Math.floor(Math.random() * 2) + 1;
            const buildingTexture = textureIndex === 1 ? cyberTextures.buildings1 : cyberTextures.buildings2;
            const emissiveTexture = textureIndex === 1 ? cyberTextures.buildingsEmissive1 : cyberTextures.buildingsEmissive2;
            
            // Configurar repeti√ß√£o da textura baseada no tamanho do pr√©dio
            const repeatX = Math.max(1, Math.floor(width / 4));
            const repeatY = Math.max(1, Math.floor(height / 8));
            const repeatZ = Math.max(1, Math.floor(depth / 4));
            
            if (buildingTexture) {
                buildingTexture.repeat.set(repeatX, repeatY);
            }
            if (emissiveTexture) {
                emissiveTexture.repeat.set(repeatX, repeatY);
            }
            
            // Material base do pr√©dio com texturas reais
            const buildingMaterial = new THREE.MeshStandardMaterial({ 
                map: buildingTexture,
                emissiveMap: emissiveTexture,
                emissive: new THREE.Color().setHSL(0.6, 0.3, 0.1),
                roughness: 0.3 + Math.random() * 0.2,
                metalness: 0.4 + Math.random() * 0.3
            });
            
            // Corpo principal do pr√©dio
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth), 
                buildingMaterial
            );
            mainBuilding.position.y = height / 2;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            buildingGroup.add(mainBuilding);
            
            // Torres g√≥ticas nos cantos
            const towerHeight = height * 0.8;
            const towerWidth = Math.min(width, depth) * 0.3;
            
            for (let i = 0; i < 4; i++) {
                const tower = new THREE.Mesh(
                    new THREE.CylinderGeometry(towerWidth/2, towerWidth/2, towerHeight, 8),
                    buildingMaterial
                );
                tower.position.y = towerHeight / 2;
                tower.position.x = (i % 2 === 0 ? 1 : -1) * (width/2 - towerWidth/2);
                tower.position.z = (i < 2 ? 1 : -1) * (depth/2 - towerWidth/2);
                tower.castShadow = true;
                buildingGroup.add(tower);
                
                // Telhado c√¥nico da torre
                const roof = new THREE.Mesh(
                    new THREE.ConeGeometry(towerWidth/2, towerHeight * 0.3, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a2a,
                        metalness: 0.8,
                        roughness: 0.2
                    })
                );
                roof.position.y = towerHeight + roof.geometry.parameters.height/2;
                roof.position.x = tower.position.x;
                roof.position.z = tower.position.z;
                roof.castShadow = true;
                buildingGroup.add(roof);
            }
            
            // Janelas com luzes neon
            const windowCount = Math.floor(height / 3);
            for (let i = 0; i < windowCount; i++) {
                const windowY = (i + 1) * (height / (windowCount + 1));
                
                // Janela frontal
                const frontWindow = new THREE.Mesh(
                    new THREE.PlaneGeometry(width * 0.6, height * 0.1),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ffcc,
                        emissive: 0x004433,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                frontWindow.position.set(0, windowY, depth/2 + 0.01);
                buildingGroup.add(frontWindow);
                
                // Janela traseira
                const backWindow = new THREE.Mesh(
                    new THREE.PlaneGeometry(width * 0.6, height * 0.1),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff6b6b,
                        emissive: 0x440022,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                backWindow.position.set(0, windowY, -depth/2 - 0.01);
                buildingGroup.add(backWindow);
            }
            
            // Luzes de neon nas bordas
            const neonColor = new THREE.Color().setHSL(Math.random(), 0.8, 0.6);
            const neonLight = new THREE.PointLight(neonColor, 0.4, 20);
            neonLight.position.set(0, height * 0.8, 0);
            buildingGroup.add(neonLight);
            
            // Hologramas flutuantes
            if (Math.random() > 0.5) {
                const hologram = new THREE.Mesh(
                    new THREE.PlaneGeometry(width * 0.8, height * 0.3),
                    new THREE.MeshStandardMaterial({ 
                        color: neonColor,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    })
                );
                hologram.position.set(0, height + 2, 0);
                hologram.rotation.x = Math.PI / 4;
                buildingGroup.add(hologram);
            }
            
            buildingGroup.position.set(x, 0, z);
            return buildingGroup;
        }
        
        // Fun√ß√£o para criar pr√©dio residencial
        function createResidentialBuilding(x, z, width, height, depth) {
            const buildingGroup = new THREE.Group();
            
            // Material residencial com textura mais suave
            const residentialMaterial = new THREE.MeshStandardMaterial({
                map: cyberTextures.buildings1,
                emissiveMap: cyberTextures.buildingsEmissive1,
                emissive: new THREE.Color().setHSL(0.1, 0.2, 0.05),
                roughness: 0.6,
                metalness: 0.2
            });
            
            if (cyberTextures.buildings1) {
                cyberTextures.buildings1.repeat.set(width / 6, height / 12);
            }
            
            // Corpo principal
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth), 
                residentialMaterial
            );
            mainBuilding.position.y = height / 2;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            buildingGroup.add(mainBuilding);
            
            // Janelas residenciais
            const windowCount = Math.floor(height / 4);
            for (let i = 0; i < windowCount; i++) {
                const windowY = (i + 1) * (height / (windowCount + 1));
                
                // Janelas com luzes quentes
                const window = new THREE.Mesh(
                    new THREE.PlaneGeometry(width * 0.3, height * 0.15),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffaa44,
                        emissive: 0x442200,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                window.position.set(width/2 + 0.01, windowY, 0);
                buildingGroup.add(window);
            }
            
            buildingGroup.position.set(x, 0, z);
            return buildingGroup;
        }
        
        // Fun√ß√£o para criar pr√©dio comercial
        function createCommercialBuilding(x, z, width, height, depth) {
            const buildingGroup = new THREE.Group();
            
            // Material comercial com textura mais met√°lica
            const commercialMaterial = new THREE.MeshStandardMaterial({
                map: cyberTextures.buildings2,
                emissiveMap: cyberTextures.buildingsEmissive2,
                emissive: new THREE.Color().setHSL(0.6, 0.4, 0.1),
                roughness: 0.2,
                metalness: 0.8
            });
            
            if (cyberTextures.buildings2) {
                cyberTextures.buildings2.repeat.set(width / 4, height / 8);
            }
            
            // Corpo principal
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth), 
                commercialMaterial
            );
            mainBuilding.position.y = height / 2;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            buildingGroup.add(mainBuilding);
            
            // An√∫ncios neon
            const adCount = Math.floor(height / 6);
            for (let i = 0; i < adCount; i++) {
                const adY = (i + 1) * (height / (adCount + 1));
                
                const ad = new THREE.Mesh(
                    new THREE.PlaneGeometry(width * 0.8, height * 0.2),
                    new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6),
                        emissive: new THREE.Color().setHSL(Math.random(), 0.8, 0.3),
                        transparent: true,
                        opacity: 0.8
                    })
                );
                ad.position.set(0, adY, depth/2 + 0.01);
                buildingGroup.add(ad);
            }
            
            buildingGroup.position.set(x, 0, z);
            return buildingGroup;
        }
        
        // Criar pr√©dios variados
        for (let i = 0; i < 20; i++) {
            const height = Math.random() * 25 + 8;
            const width = Math.random() * 8 + 4;
            const depth = Math.random() * 8 + 4;
            
            const building = createGothicTechBuilding(
                (Math.random() - 0.5) * 150, 
                (Math.random() - 0.5) * 150,
                width, height, depth
            );
            
            scene.add(building);
        }
        
        // Criar pr√©dios residenciais
        for (let i = 0; i < 15; i++) {
            const height = Math.random() * 15 + 5;
            const width = Math.random() * 6 + 3;
            const depth = Math.random() * 6 + 3;
            
            const building = createResidentialBuilding(
                (Math.random() - 0.5) * 150, 
                (Math.random() - 0.5) * 150,
                width, height, depth
            );
            
            scene.add(building);
        }
        
        // Criar pr√©dios comerciais
        for (let i = 0; i < 10; i++) {
            const height = Math.random() * 30 + 10;
            const width = Math.random() * 12 + 6;
            const depth = Math.random() * 12 + 6;
            
            const building = createCommercialBuilding(
                (Math.random() - 0.5) * 150, 
                (Math.random() - 0.5) * 150,
                width, height, depth
            );
            
            scene.add(building);
        }
        
        // Adicionar estruturas especiais
        // Catedral central
        const cathedral = createGothicTechBuilding(0, 0, 15, 35, 20);
        scene.add(cathedral);
        
        // Torres de energia
        for (let i = 0; i < 5; i++) {
            const energyTower = new THREE.Group();
            
            const towerHeight = 40 + Math.random() * 20;
            const tower = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 3, towerHeight, 12),
                new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a3a,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: 0x001122
                })
            );
            tower.position.y = towerHeight / 2;
            tower.castShadow = true;
            energyTower.add(tower);
            
            // An√©is de energia
            for (let j = 0; j < 3; j++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(4 + j * 2, 0.2, 8, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ffcc,
                        emissive: 0x004433,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                ring.position.y = towerHeight * 0.3 + j * towerHeight * 0.2;
                energyTower.add(ring);
            }
            
            energyTower.position.set(
                (Math.random() - 0.5) * 200, 
                0, 
                (Math.random() - 0.5) * 200
            );
            scene.add(energyTower);
        }
        
        // Sistema de estradas cyberpunk
        function createCyberRoad(x, z, width, length, rotation = 0) {
            const roadGeometry = new THREE.PlaneGeometry(width, length, 10, 10);
            const roadMaterial = new THREE.MeshStandardMaterial({
                map: cyberTextures.roads,
                emissiveMap: cyberTextures.roadsEmissive,
                color: 0x2a2a2a,
                roughness: 0.8,
                metalness: 0.1,
                emissive: 0x001122
            });
            
            if (cyberTextures.roads) {
                cyberTextures.roads.repeat.set(width / 4, length / 4);
            }
            if (cyberTextures.roadsEmissive) {
                cyberTextures.roadsEmissive.repeat.set(width / 4, length / 4);
            }
            
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.set(x, 0.02, z);
            road.rotation.y = rotation;
            road.receiveShadow = true;
            scene.add(road);
            
            // Adicionar linhas de neon na estrada (melhoradas)
            const lineGeometry = new THREE.PlaneGeometry(width * 0.8, 0.5);
            const lineMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffcc,
                emissive: 0x004433,
                transparent: true,
                opacity: 0.8
            });
            
            for (let i = 0; i < 3; i++) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2;
                line.position.set(x, 0.03, z + (i - 1) * length / 3);
                line.rotation.y = rotation;
                scene.add(line);
            }
            
            // Adicionar postes de luz nas laterais da estrada
            for (let i = 0; i < Math.floor(length / 20); i++) {
                const poste = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 6, 8),
                    new THREE.MeshStandardMaterial({
                        map: cyberTextures.props,
                        color: 0x333333,
                        metalness: 0.8,
                        roughness: 0.2
                    })
                );
                poste.position.set(x + width/2 + 1, 3, z + (i - Math.floor(length / 40)) * 20);
                poste.rotation.y = rotation;
                scene.add(poste);
                
                // Luz do poste
                const posteLight = new THREE.PointLight(0x00ffcc, 0.6, 15);
                posteLight.position.set(x + width/2 + 1, 6, z + (i - Math.floor(length / 40)) * 20);
                scene.add(posteLight);
            }
        }
        
        // Criar rede de estradas
        createCyberRoad(0, 0, 200, 8, 0); // Estrada principal horizontal
        createCyberRoad(0, 0, 8, 200, Math.PI / 2); // Estrada principal vertical
        createCyberRoad(-50, 0, 100, 6, 0); // Estrada secund√°ria
        createCyberRoad(0, -50, 6, 100, Math.PI / 2); // Estrada secund√°ria
        createCyberRoad(50, 0, 100, 6, 0); // Estrada secund√°ria
        createCyberRoad(0, 50, 6, 100, Math.PI / 2); // Estrada secund√°ria
        
        // Fun√ß√£o para criar pr√©dio VoxelCity (estilo retr√¥-futurista)
        function createVoxelBuilding(x, z, width, height, depth) {
            const buildingGroup = new THREE.Group();
            
            // Escolher textura voxel aleat√≥ria
            const voxelTextures = [cyberTextures.voxelBuildings1, cyberTextures.voxelBuildings2, cyberTextures.voxelBuildings3];
            const voxelTexture = voxelTextures[Math.floor(Math.random() * voxelTextures.length)];
            
            // Material voxel com textura especial
            const voxelMaterial = new THREE.MeshStandardMaterial({
                map: voxelTexture,
                color: new THREE.Color().setHSL(Math.random(), 0.3, 0.5),
                roughness: 0.8,
                metalness: 0.1,
                emissive: new THREE.Color().setHSL(Math.random(), 0.5, 0.1)
            });
            
            if (voxelTexture) {
                voxelTexture.repeat.set(width / 8, height / 16);
            }
            
            // Corpo principal em estilo voxel (mais blocado)
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth), 
                voxelMaterial
            );
            mainBuilding.position.y = height / 2;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            buildingGroup.add(mainBuilding);
            
            // Adicionar blocos menores para efeito voxel
            for (let i = 0; i < 5; i++) {
                const blockSize = Math.random() * 2 + 1;
                const block = new THREE.Mesh(
                    new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                    voxelMaterial
                );
                block.position.set(
                    (Math.random() - 0.5) * width,
                    height + blockSize / 2,
                    (Math.random() - 0.5) * depth
                );
                buildingGroup.add(block);
            }
            
            // Luzes neon caracter√≠sticas do estilo voxel
            const neonLight = new THREE.PointLight(
                new THREE.Color().setHSL(Math.random(), 0.8, 0.6), 
                0.5, 
                15
            );
            neonLight.position.set(0, height * 0.8, 0);
            buildingGroup.add(neonLight);
            
            buildingGroup.position.set(x, 0, z);
            return buildingGroup;
        }
        
        // Fun√ß√£o para criar props urbanos
        function createUrbanProps(x, z, count = 5) {
            const propsGroup = new THREE.Group();
            
            for (let i = 0; i < count; i++) {
                const propType = Math.floor(Math.random() * 4);
                let prop;
                
                switch(propType) {
                    case 0: // Poste de luz
                        prop = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.2, 0.2, 8, 8),
                            new THREE.MeshStandardMaterial({
                                map: cyberTextures.props,
                                color: 0x333333,
                                metalness: 0.8,
                                roughness: 0.2
                            })
                        );
                        prop.position.y = 4;
                        
                        // Luz no topo
                        const light = new THREE.PointLight(0x00ffcc, 0.8, 20);
                        light.position.set(0, 8, 0);
                        prop.add(light);
                        break;
                        
                    case 1: // Lixeira
                        prop = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.8, 0.8, 1.5, 8),
                            new THREE.MeshStandardMaterial({
                                map: cyberTextures.props,
                                color: 0x444444,
                                metalness: 0.6,
                                roughness: 0.4
                            })
                        );
                        prop.position.y = 0.75;
                        break;
                        
                    case 2: // Placa de sinaliza√ß√£o
                        prop = new THREE.Mesh(
                            new THREE.PlaneGeometry(2, 1),
                            new THREE.MeshStandardMaterial({
                                map: cyberTextures.props,
                                color: 0x00ffcc,
                                emissive: 0x004433,
                                transparent: true,
                                opacity: 0.9
                            })
                        );
                        prop.position.y = 3;
                        prop.rotation.y = Math.random() * Math.PI * 2;
                        break;
                        
                    case 3: // Caixa de utilidades
                        prop = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            new THREE.MeshStandardMaterial({
                                map: cyberTextures.props,
                                color: 0x666666,
                                metalness: 0.7,
                                roughness: 0.3
                            })
                        );
                        prop.position.y = 0.5;
                        break;
                }
                
                if (prop) {
                    prop.position.x += (Math.random() - 0.5) * 10;
                    prop.position.z += (Math.random() - 0.5) * 10;
                    propsGroup.add(prop);
                }
            }
            
            propsGroup.position.set(x, 0, z);
            return propsGroup;
        }
        
        // Criar √°rea VoxelCity (bairro retr√¥-futurista)
        for (let i = 0; i < 8; i++) {
            const height = Math.random() * 20 + 10;
            const width = Math.random() * 6 + 4;
            const depth = Math.random() * 6 + 4;
            
            const voxelBuilding = createVoxelBuilding(
                (Math.random() - 0.5) * 100 + 80, // √Årea espec√≠fica
                (Math.random() - 0.5) * 100 + 80,
                width, height, depth
            );
            
            scene.add(voxelBuilding);
        }
        
        // Criar props urbanos espalhados pela cidade
        for (let i = 0; i < 20; i++) {
            const props = createUrbanProps(
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200,
                Math.floor(Math.random() * 3) + 2
            );
            scene.add(props);
        }

        // Personagem (c√°psula)
        const playerGeometry = new THREE.CapsuleGeometry(0.5, 1, 4, 16);
        const playerMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x00ffcc,
            emissive: 0x001111,
            roughness: 0.3,
            metalness: 0.7
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = 1.5;
        player.castShadow = true;
        scene.add(player);

        // Sistema de controles
        const keysPressed = {};
        let isRightMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraOffset = new THREE.Vector3(0, 5, 10);
        let playerRotation = 0;
        let cameraDistance = 10;
        let cameraHeight = 5;
        let isFirstPerson = false;
        let isFlying = false;
        let playerVelocity = new THREE.Vector3(0, 0, 0);
        let isRunning = false;

        // Event listeners para controles
        document.addEventListener('keydown', (e) => { 
            keysPressed[e.key.toLowerCase()] = true; 
            
            // Alternar entre primeira e terceira pessoa com a tecla V
            if (e.key.toLowerCase() === 'v') {
                isFirstPerson = !isFirstPerson;
                if (isFirstPerson) {
                    cameraDistance = 0;
                    cameraHeight = 1.5;
                } else {
                    cameraDistance = 10;
                    cameraHeight = 5;
                }
            }
            
            // Alternar modo de voo com a tecla F
            if (e.key.toLowerCase() === 'f') {
                isFlying = !isFlying;
                if (isFlying) {
                    playerVelocity.y = 0; // Parar movimento vertical ao ativar voo
                }
                // Atualizar indicador visual
                const flyingStatus = document.getElementById('flying-status');
                if (flyingStatus) {
                    flyingStatus.style.display = isFlying ? 'block' : 'none';
                }
            }
            
            // Detectar SHIFT para corrida
            if (e.key === 'Shift') {
                isRunning = true;
                // Atualizar indicador visual
                const runningStatus = document.getElementById('running-status');
                if (runningStatus) {
                    runningStatus.style.display = 'block';
                }
            }
        });
        
        document.addEventListener('keyup', (e) => { 
            keysPressed[e.key.toLowerCase()] = false; 
            
            // Detectar quando soltar SHIFT
            if (e.key === 'Shift') {
                isRunning = false;
                // Atualizar indicador visual
                const runningStatus = document.getElementById('running-status');
                if (runningStatus) {
                    runningStatus.style.display = 'none';
                }
            }
        });

        // Prevenir menu de contexto
        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // Controles do mouse para c√¢mera
        document.addEventListener('mousedown', (e) => { 
            if (e.button === 2) { 
                isRightMouseDown = true; 
                previousMousePosition = { x: e.clientX, y: e.clientY }; 
            } 
        });

        document.addEventListener('mouseup', (e) => { 
            if (e.button === 2) { 
                isRightMouseDown = false; 
            } 
        });

        document.addEventListener('mousemove', (e) => {
            if (!isRightMouseDown) return;
            
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            
            // Rota√ß√£o horizontal da c√¢mera
            const yAxis = new THREE.Vector3(0, 1, 0);
            cameraOffset.applyAxisAngle(yAxis, -deltaX * 0.005);
            
            // Rota√ß√£o vertical da c√¢mera
            const xAxis = new THREE.Vector3().crossVectors(yAxis, cameraOffset).normalize();
            cameraOffset.applyAxisAngle(xAxis, -deltaY * 0.005);
            
            // Limitar altura da c√¢mera baseado no modo
            if (isFirstPerson) {
                // Primeira pessoa: altura fixa, mas pode olhar para cima/baixo
                cameraOffset.y = cameraHeight;
                // Limitar √¢ngulo vertical para n√£o virar de cabe√ßa para baixo
                const verticalAngle = Math.asin(cameraOffset.y / cameraOffset.length());
                if (verticalAngle > Math.PI/2 - 0.1) {
                    cameraOffset.y = Math.sin(Math.PI/2 - 0.1) * cameraOffset.length();
                }
                if (verticalAngle < -Math.PI/2 + 0.1) {
                    cameraOffset.y = Math.sin(-Math.PI/2 + 0.1) * cameraOffset.length();
                }
            } else {
                // Terceira pessoa: altura vari√°vel com limites
                if (cameraOffset.y < 2) cameraOffset.y = 2;
                if (cameraOffset.y > 15) cameraOffset.y = 15;
            }
            
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        // Loop de anima√ß√£o
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            // Calcular velocidade base
            let baseSpeed = 5;
            if (isRunning) {
                baseSpeed *= 2; // Dobrar velocidade ao correr
            }
            const moveSpeed = baseSpeed * delta;
            
            // Movimento do personagem relativo √† c√¢mera
            const moveVector = new THREE.Vector3();
            
            // Obter dire√ß√£o da c√¢mera
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            // Para movimento no ch√£o, ignorar componente Y
            if (!isFlying) {
                cameraDirection.y = 0;
            }
            cameraDirection.normalize();
            
            // Dire√ß√£o perpendicular √† c√¢mera (para movimento lateral)
            const rightDirection = new THREE.Vector3();
            rightDirection.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));
            rightDirection.normalize();
            
            // Movimento horizontal (WASD)
            if (keysPressed['w']) {
                moveVector.add(cameraDirection.clone().multiplyScalar(moveSpeed));
            }
            if (keysPressed['s']) {
                moveVector.add(cameraDirection.clone().multiplyScalar(-moveSpeed));
            }
            if (keysPressed['a']) {
                moveVector.add(rightDirection.clone().multiplyScalar(-moveSpeed));
            }
            if (keysPressed['d']) {
                moveVector.add(rightDirection.clone().multiplyScalar(moveSpeed));
            }
            
            // Movimento vertical (apenas no modo voo)
            if (isFlying) {
                if (keysPressed[' ']) { // Espa√ßo para subir
                    moveVector.y += moveSpeed;
                }
                if (keysPressed['c']) { // C para descer
                    moveVector.y -= moveSpeed;
                }
            } else {
                // No ch√£o, aplicar gravidade
                playerVelocity.y -= 20 * delta; // Gravidade
                moveVector.y = playerVelocity.y * delta;
                
                // Verificar colis√£o com o ch√£o
                if (player.position.y + moveVector.y <= 1.5) {
                    player.position.y = 1.5;
                    playerVelocity.y = 0;
                    moveVector.y = 0;
                }
                
                // Pulo (apenas no ch√£o)
                if (keysPressed[' '] && player.position.y <= 1.6) {
                    playerVelocity.y = 15; // For√ßa do pulo
                }
            }
            
            // Aplicar movimento
            player.position.add(moveVector);
            
            // Rotacionar personagem na dire√ß√£o do movimento (apenas horizontal)
            if (moveVector.x !== 0 || moveVector.z !== 0) {
                const moveDirection = new THREE.Vector3(moveVector.x, 0, moveVector.z).normalize();
                playerRotation = Math.atan2(moveDirection.x, moveDirection.z);
                player.rotation.y = playerRotation;
            }
            
            // Atualizar posi√ß√£o da c√¢mera
            if (isFirstPerson) {
                // Primeira pessoa: c√¢mera na posi√ß√£o do personagem
                camera.position.copy(player.position);
                camera.position.y += cameraHeight;
                
                // Olhar na dire√ß√£o da c√¢mera
                const lookDirection = new THREE.Vector3();
                camera.getWorldDirection(lookDirection);
                const lookTarget = player.position.clone().add(lookDirection.multiplyScalar(10));
                camera.lookAt(lookTarget);
            } else {
                // Terceira pessoa: c√¢mera atr√°s do personagem
                let targetCameraPosition = player.position.clone().add(cameraOffset);
                
                // Verificar se a c√¢mera n√£o est√° abaixo do ch√£o
                if (targetCameraPosition.y < 1) {
                    targetCameraPosition.y = 1;
                }
                
                camera.position.lerp(targetCameraPosition, 0.2);
                camera.lookAt(player.position);
            }
            
            // Renderizar cena
            renderer.render(scene, camera);
        }

        // Redimensionamento da janela
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Iniciar anima√ß√£o
        animate();
    </script>
</body>
</html>
