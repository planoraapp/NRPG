<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prot√≥tipo 3D - RPG G√≥tico Hi-Tech (Embedded Textures)</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Courier New', Courier, monospace; 
        }
        canvas { 
            display: block; 
        }
        #info-panel { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            padding: 15px; 
            background-color: rgba(0, 0, 0, 0.7); 
            color: #00ffcc; 
            border: 2px solid #00ffcc; 
            border-radius: 8px; 
            font-size: 14px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
        }
        #info-panel h3 {
            margin: 0 0 10px 0;
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }
        #info-panel p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h3>üåô RPG G√≥tico Hi-Tech - Prot√≥tipo</h3>
        <p><strong>Movimento:</strong> W, A, S, D</p>
        <p><strong>C√¢mera:</strong> Bot√£o direito + Arrastar</p>
        <p><strong>Vis√£o:</strong> V (1¬™/3¬™ pessoa)</p>
        <p><strong>Atmosfera:</strong> Tecno-Medieval</p>
        <p><strong>Texturas:</strong> Embedded (sem CORS)</p>
    </div>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    { 
        "imports": { 
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js" 
        } 
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';

        // Inicializa√ß√£o da cena
        const scene = new THREE.Scene();
        
        // Configura√ß√£o da n√©voa para atmosfera sombria
        scene.fog = new THREE.Fog(0x0a0a1a, 20, 100);
        
        // Configura√ß√£o da c√¢mera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        
        // Configura√ß√£o do renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x0a0a1a);
        document.body.appendChild(renderer.domElement);

        // Ilumina√ß√£o ambiente (tons azulados)
        const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
        scene.add(ambientLight);

        // Luz direcional principal
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -25;
        directionalLight.shadow.camera.right = 25;
        directionalLight.shadow.camera.top = 25;
        directionalLight.shadow.camera.bottom = -25;
        scene.add(directionalLight);

        // Luzes de neon para atmosfera cyberpunk
        const neonLight1 = new THREE.PointLight(0x00ffcc, 0.5, 30);
        neonLight1.position.set(15, 8, 15);
        scene.add(neonLight1);

        const neonLight2 = new THREE.PointLight(0xff6b6b, 0.4, 25);
        neonLight2.position.set(-20, 6, -10);
        scene.add(neonLight2);

        const neonLight3 = new THREE.PointLight(0x9d4edd, 0.3, 20);
        neonLight3.position.set(0, 10, -25);
        scene.add(neonLight3);

        // Ch√£o do cen√°rio com texturas de grama embutidas
        const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
        
        // Fun√ß√£o para criar textura procedural de grama
        function createGrassTexture(size = 256, type = 'normal') {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Base escura
            ctx.fillStyle = type === 'dark' ? '#050a05' : '#0a1a0a';
            ctx.fillRect(0, 0, size, size);
            
            // Adicionar varia√ß√µes de cor de fundo
            const iterations = type === 'stones' ? 1200 : 1000;
            for (let i = 0; i < iterations; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = Math.random() * 3 + 1;
                
                const hue = 120 + Math.random() * 20;
                const saturation = type === 'dark' ? 20 + Math.random() * 15 : 30 + Math.random() * 20;
                const lightness = type === 'dark' ? 5 + Math.random() * 10 : 10 + Math.random() * 15;
                
                ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Adicionar pedras se for tipo stones
            if (type === 'stones') {
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const radius = Math.random() * 8 + 3;
                    
                    const stoneHue = 0 + Math.random() * 30;
                    const stoneSaturation = 10 + Math.random() * 20;
                    const stoneLightness = 15 + Math.random() * 20;
                    
                    ctx.fillStyle = `hsl(${stoneHue}, ${stoneSaturation}%, ${stoneLightness}%)`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Adicionar fios de grama
            const grassIterations = type === 'dark' ? 1500 : 2000;
            for (let i = 0; i < grassIterations; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const length = Math.random() * 8 + 2;
                const angle = Math.random() * Math.PI * 2;
                
                const hue = 120 + Math.random() * 30;
                const saturation = 40 + Math.random() * 30;
                const lightness = type === 'dark' ? 8 + Math.random() * 12 : 15 + Math.random() * 20;
                
                ctx.strokeStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                ctx.lineWidth = Math.random() * 2 + 0.5;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        // Criar texturas de grama
        const grassTexture = createGrassTexture(256, 'normal');
        grassTexture.repeat.set(20, 20);
        
        const darkGrassTexture = createGrassTexture(256, 'dark');
        darkGrassTexture.repeat.set(15, 15);
        
        const stonesTexture = createGrassTexture(256, 'stones');
        stonesTexture.repeat.set(12, 12);
        
        // Criar material com m√∫ltiplas texturas usando vertex colors
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            map: grassTexture,
            color: 0x2a3a2a, // Cor base verde escura
            roughness: 0.8,
            metalness: 0.1,
            emissive: 0x001100
        });
        
        // Adicionar varia√ß√£o de texturas baseada na posi√ß√£o
        const vertices = groundGeometry.attributes.position.array;
        const colors = [];
        
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 2];
            
            // Criar padr√£o de varia√ß√£o baseado na posi√ß√£o
            const noise1 = Math.sin(x * 0.01) * Math.cos(z * 0.01);
            const noise2 = Math.sin(x * 0.03) * Math.cos(z * 0.03);
            const variation = (noise1 + noise2) * 0.5;
            
            if (variation > 0.3) {
                // √Årea de grama normal
                colors.push(1.0, 1.0, 1.0); // Branco = usar textura principal
            } else if (variation > -0.2) {
                // √Årea de grama escura
                colors.push(0.7, 0.7, 0.7); // Cinza = usar textura escura
            } else {
                // √Årea com pedras
                colors.push(0.5, 0.5, 0.5); // Cinza escuro = usar textura com pedras
            }
        }
        
        groundGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Adicionar algumas √°reas especiais com texturas diferentes
        function addGrassArea(x, z, width, height, textureType) {
            const areaGeometry = new THREE.PlaneGeometry(width, height, 10, 10);
            let areaTexture;
            let areaColor;
            
            switch(textureType) {
                case 'dark':
                    areaTexture = darkGrassTexture;
                    areaColor = 0x1a2a1a;
                    break;
                case 'stones':
                    areaTexture = stonesTexture;
                    areaColor = 0x2a2a1a;
                    break;
                default:
                    areaTexture = grassTexture;
                    areaColor = 0x2a3a2a;
            }
            
            const areaMaterial = new THREE.MeshStandardMaterial({
                map: areaTexture,
                color: areaColor,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const area = new THREE.Mesh(areaGeometry, areaMaterial);
            area.rotation.x = -Math.PI / 2;
            area.position.set(x, 0.01, z); // Ligeiramente acima do ch√£o principal
            area.receiveShadow = true;
            scene.add(area);
        }
        
        // Adicionar √°reas variadas de grama
        addGrassArea(-50, -50, 30, 30, 'dark');
        addGrassArea(60, 40, 25, 25, 'stones');
        addGrassArea(-30, 70, 20, 20, 'dark');
        addGrassArea(80, -80, 35, 35, 'stones');

        // Fun√ß√£o para criar pr√©dio g√≥tico hi-tech
        function createGothicTechBuilding(x, z, width, height, depth) {
            const buildingGroup = new THREE.Group();
            
            // Material base do pr√©dio
            const buildingMaterial = new THREE.MeshStandardMaterial({ 
                color: new THREE.Color().setHSL(0.6, 0.1, 0.2 + Math.random() * 0.1),
                roughness: 0.4 + Math.random() * 0.3,
                metalness: 0.3 + Math.random() * 0.4,
                emissive: new THREE.Color().setHSL(0.6, 0.3, 0.02)
            });
            
            // Corpo principal do pr√©dio
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth), 
                buildingMaterial
            );
            mainBuilding.position.y = height / 2;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            buildingGroup.add(mainBuilding);
            
            // Torres g√≥ticas nos cantos
            const towerHeight = height * 0.8;
            const towerWidth = Math.min(width, depth) * 0.3;
            
            for (let i = 0; i < 4; i++) {
                const tower = new THREE.Mesh(
                    new THREE.CylinderGeometry(towerWidth/2, towerWidth/2, towerHeight, 8),
                    buildingMaterial
                );
                tower.position.y = towerHeight / 2;
                tower.position.x = (i % 2 === 0 ? 1 : -1) * (width/2 - towerWidth/2);
                tower.position.z = (i < 2 ? 1 : -1) * (depth/2 - towerWidth/2);
                tower.castShadow = true;
                buildingGroup.add(tower);
                
                // Telhado c√¥nico da torre
                const roof = new THREE.Mesh(
                    new THREE.ConeGeometry(towerWidth/2, towerHeight * 0.3, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a2a,
                        metalness: 0.8,
                        roughness: 0.2
                    })
                );
                roof.position.y = towerHeight + roof.geometry.parameters.height/2;
                roof.position.x = tower.position.x;
                roof.position.z = tower.position.z;
                roof.castShadow = true;
                buildingGroup.add(roof);
            }
            
            // Janelas com luzes neon
            const windowCount = Math.floor(height / 3);
            for (let i = 0; i < windowCount; i++) {
                const windowY = (i + 1) * (height / (windowCount + 1));
                
                // Janela frontal
                const frontWindow = new THREE.Mesh(
                    new THREE.PlaneGeometry(width * 0.6, height * 0.1),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ffcc,
                        emissive: 0x004433,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                frontWindow.position.set(0, windowY, depth/2 + 0.01);
                buildingGroup.add(frontWindow);
                
                // Janela traseira
                const backWindow = new THREE.Mesh(
                    new THREE.PlaneGeometry(width * 0.6, height * 0.1),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff6b6b,
                        emissive: 0x440022,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                backWindow.position.set(0, windowY, -depth/2 - 0.01);
                buildingGroup.add(backWindow);
            }
            
            // Luzes de neon nas bordas
            const neonColor = new THREE.Color().setHSL(Math.random(), 0.8, 0.6);
            const neonLight = new THREE.PointLight(neonColor, 0.4, 20);
            neonLight.position.set(0, height * 0.8, 0);
            buildingGroup.add(neonLight);
            
            // Hologramas flutuantes
            if (Math.random() > 0.5) {
                const hologram = new THREE.Mesh(
                    new THREE.PlaneGeometry(width * 0.8, height * 0.3),
                    new THREE.MeshStandardMaterial({ 
                        color: neonColor,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    })
                );
                hologram.position.set(0, height + 2, 0);
                hologram.rotation.x = Math.PI / 4;
                buildingGroup.add(hologram);
            }
            
            buildingGroup.position.set(x, 0, z);
            return buildingGroup;
        }
        
        // Criar pr√©dios variados
        for (let i = 0; i < 30; i++) {
            const height = Math.random() * 25 + 8;
            const width = Math.random() * 8 + 4;
            const depth = Math.random() * 8 + 4;
            
            const building = createGothicTechBuilding(
                (Math.random() - 0.5) * 150, 
                (Math.random() - 0.5) * 150,
                width, height, depth
            );
            
            scene.add(building);
        }
        
        // Adicionar estruturas especiais
        // Catedral central
        const cathedral = createGothicTechBuilding(0, 0, 15, 35, 20);
        scene.add(cathedral);
        
        // Torres de energia
        for (let i = 0; i < 5; i++) {
            const energyTower = new THREE.Group();
            
            const towerHeight = 40 + Math.random() * 20;
            const tower = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 3, towerHeight, 12),
                new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a3a,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: 0x001122
                })
            );
            tower.position.y = towerHeight / 2;
            tower.castShadow = true;
            energyTower.add(tower);
            
            // An√©is de energia
            for (let j = 0; j < 3; j++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(4 + j * 2, 0.2, 8, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ffcc,
                        emissive: 0x004433,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                ring.position.y = towerHeight * 0.3 + j * towerHeight * 0.2;
                energyTower.add(ring);
            }
            
            energyTower.position.set(
                (Math.random() - 0.5) * 200, 
                0, 
                (Math.random() - 0.5) * 200
            );
            scene.add(energyTower);
        }

        // Personagem (c√°psula)
        const playerGeometry = new THREE.CapsuleGeometry(0.5, 1, 4, 16);
        const playerMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x00ffcc,
            emissive: 0x001111,
            roughness: 0.3,
            metalness: 0.7
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = 1.5;
        player.castShadow = true;
        scene.add(player);

        // Sistema de controles
        const keysPressed = {};
        let isRightMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraOffset = new THREE.Vector3(0, 5, 10);
        let playerRotation = 0;
        let cameraDistance = 10;
        let cameraHeight = 5;
        let isFirstPerson = false;

        // Event listeners para controles
        document.addEventListener('keydown', (e) => { 
            keysPressed[e.key.toLowerCase()] = true; 
            
            // Alternar entre primeira e terceira pessoa com a tecla V
            if (e.key.toLowerCase() === 'v') {
                isFirstPerson = !isFirstPerson;
                if (isFirstPerson) {
                    cameraDistance = 0;
                    cameraHeight = 1.5;
                } else {
                    cameraDistance = 10;
                    cameraHeight = 5;
                }
            }
        });
        
        document.addEventListener('keyup', (e) => { 
            keysPressed[e.key.toLowerCase()] = false; 
        });

        // Prevenir menu de contexto
        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // Controles do mouse para c√¢mera
        document.addEventListener('mousedown', (e) => { 
            if (e.button === 2) { 
                isRightMouseDown = true; 
                previousMousePosition = { x: e.clientX, y: e.clientY }; 
            } 
        });

        document.addEventListener('mouseup', (e) => { 
            if (e.button === 2) { 
                isRightMouseDown = false; 
            } 
        });

        document.addEventListener('mousemove', (e) => {
            if (!isRightMouseDown) return;
            
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            
            // Rota√ß√£o horizontal da c√¢mera
            const yAxis = new THREE.Vector3(0, 1, 0);
            cameraOffset.applyAxisAngle(yAxis, -deltaX * 0.005);
            
            // Rota√ß√£o vertical da c√¢mera
            const xAxis = new THREE.Vector3().crossVectors(yAxis, cameraOffset).normalize();
            cameraOffset.applyAxisAngle(xAxis, -deltaY * 0.005);
            
            // Limitar altura da c√¢mera baseado no modo
            if (isFirstPerson) {
                // Primeira pessoa: altura fixa, mas pode olhar para cima/baixo
                cameraOffset.y = cameraHeight;
                // Limitar √¢ngulo vertical para n√£o virar de cabe√ßa para baixo
                const verticalAngle = Math.asin(cameraOffset.y / cameraOffset.length());
                if (verticalAngle > Math.PI/2 - 0.1) {
                    cameraOffset.y = Math.sin(Math.PI/2 - 0.1) * cameraOffset.length();
                }
                if (verticalAngle < -Math.PI/2 + 0.1) {
                    cameraOffset.y = Math.sin(-Math.PI/2 + 0.1) * cameraOffset.length();
                }
            } else {
                // Terceira pessoa: altura vari√°vel com limites
                if (cameraOffset.y < 2) cameraOffset.y = 2;
                if (cameraOffset.y > 15) cameraOffset.y = 15;
            }
            
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        // Loop de anima√ß√£o
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const moveSpeed = 5 * delta;
            
            // Movimento do personagem relativo √† c√¢mera
            const moveVector = new THREE.Vector3();
            
            // Obter dire√ß√£o da c√¢mera (sem componente Y para movimento horizontal)
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            cameraDirection.y = 0;
            cameraDirection.normalize();
            
            // Dire√ß√£o perpendicular √† c√¢mera (para movimento lateral)
            const rightDirection = new THREE.Vector3();
            rightDirection.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));
            rightDirection.normalize();
            
            if (keysPressed['w']) {
                moveVector.add(cameraDirection.clone().multiplyScalar(moveSpeed));
            }
            if (keysPressed['s']) {
                moveVector.add(cameraDirection.clone().multiplyScalar(-moveSpeed));
            }
            if (keysPressed['a']) {
                moveVector.add(rightDirection.clone().multiplyScalar(-moveSpeed));
            }
            if (keysPressed['d']) {
                moveVector.add(rightDirection.clone().multiplyScalar(moveSpeed));
            }
            
            // Aplicar movimento
            player.position.add(moveVector);
            
            // Rotacionar personagem na dire√ß√£o do movimento
            if (moveVector.length() > 0) {
                const moveDirection = moveVector.clone().normalize();
                playerRotation = Math.atan2(moveDirection.x, moveDirection.z);
                player.rotation.y = playerRotation;
            }
            
            // Atualizar posi√ß√£o da c√¢mera
            if (isFirstPerson) {
                // Primeira pessoa: c√¢mera na posi√ß√£o do personagem
                camera.position.copy(player.position);
                camera.position.y += cameraHeight;
                
                // Olhar na dire√ß√£o da c√¢mera
                const lookDirection = new THREE.Vector3();
                camera.getWorldDirection(lookDirection);
                const lookTarget = player.position.clone().add(lookDirection.multiplyScalar(10));
                camera.lookAt(lookTarget);
            } else {
                // Terceira pessoa: c√¢mera atr√°s do personagem
                let targetCameraPosition = player.position.clone().add(cameraOffset);
                
                // Verificar se a c√¢mera n√£o est√° abaixo do ch√£o
                if (targetCameraPosition.y < 1) {
                    targetCameraPosition.y = 1;
                }
                
                camera.position.lerp(targetCameraPosition, 0.2);
                camera.lookAt(player.position);
            }
            
            // Renderizar cena
            renderer.render(scene, camera);
        }

        // Redimensionamento da janela
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Iniciar anima√ß√£o
        animate();
    </script>
</body>
</html>
